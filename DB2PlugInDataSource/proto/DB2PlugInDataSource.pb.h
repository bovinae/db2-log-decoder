// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DB2PlugInDataSource.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_DB2PlugInDataSource_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_DB2PlugInDataSource_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_DB2PlugInDataSource_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_DB2PlugInDataSource_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_DB2PlugInDataSource_2eproto;
namespace tapdata {
class ControlResponse;
struct ControlResponseDefaultTypeInternal;
extern ControlResponseDefaultTypeInternal _ControlResponse_default_instance_;
class GetReadLogTaskStateResponse;
struct GetReadLogTaskStateResponseDefaultTypeInternal;
extern GetReadLogTaskStateResponseDefaultTypeInternal _GetReadLogTaskStateResponse_default_instance_;
class ListReadLogTaskStatesRequest;
struct ListReadLogTaskStatesRequestDefaultTypeInternal;
extern ListReadLogTaskStatesRequestDefaultTypeInternal _ListReadLogTaskStatesRequest_default_instance_;
class ListReadLogTaskStatesResponse;
struct ListReadLogTaskStatesResponseDefaultTypeInternal;
extern ListReadLogTaskStatesResponseDefaultTypeInternal _ListReadLogTaskStatesResponse_default_instance_;
class MessageHeader;
struct MessageHeaderDefaultTypeInternal;
extern MessageHeaderDefaultTypeInternal _MessageHeader_default_instance_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PingResponse;
struct PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
class PushReadLogRequest;
struct PushReadLogRequestDefaultTypeInternal;
extern PushReadLogRequestDefaultTypeInternal _PushReadLogRequest_default_instance_;
class PushReadLogResponse;
struct PushReadLogResponseDefaultTypeInternal;
extern PushReadLogResponseDefaultTypeInternal _PushReadLogResponse_default_instance_;
class ReadLogPayload;
struct ReadLogPayloadDefaultTypeInternal;
extern ReadLogPayloadDefaultTypeInternal _ReadLogPayload_default_instance_;
class ReadLogRequest;
struct ReadLogRequestDefaultTypeInternal;
extern ReadLogRequestDefaultTypeInternal _ReadLogRequest_default_instance_;
class ReadLogResponse;
struct ReadLogResponseDefaultTypeInternal;
extern ReadLogResponseDefaultTypeInternal _ReadLogResponse_default_instance_;
class ReadLogTaskState;
struct ReadLogTaskStateDefaultTypeInternal;
extern ReadLogTaskStateDefaultTypeInternal _ReadLogTaskState_default_instance_;
class ReaderSource;
struct ReaderSourceDefaultTypeInternal;
extern ReaderSourceDefaultTypeInternal _ReaderSource_default_instance_;
class ServerInfoResponse;
struct ServerInfoResponseDefaultTypeInternal;
extern ServerInfoResponseDefaultTypeInternal _ServerInfoResponse_default_instance_;
class SourceTable;
struct SourceTableDefaultTypeInternal;
extern SourceTableDefaultTypeInternal _SourceTable_default_instance_;
class TaskHandleRequest;
struct TaskHandleRequestDefaultTypeInternal;
extern TaskHandleRequestDefaultTypeInternal _TaskHandleRequest_default_instance_;
class WriterTarget;
struct WriterTargetDefaultTypeInternal;
extern WriterTargetDefaultTypeInternal _WriterTarget_default_instance_;
}  // namespace tapdata
PROTOBUF_NAMESPACE_OPEN
template<> ::tapdata::ControlResponse* Arena::CreateMaybeMessage<::tapdata::ControlResponse>(Arena*);
template<> ::tapdata::GetReadLogTaskStateResponse* Arena::CreateMaybeMessage<::tapdata::GetReadLogTaskStateResponse>(Arena*);
template<> ::tapdata::ListReadLogTaskStatesRequest* Arena::CreateMaybeMessage<::tapdata::ListReadLogTaskStatesRequest>(Arena*);
template<> ::tapdata::ListReadLogTaskStatesResponse* Arena::CreateMaybeMessage<::tapdata::ListReadLogTaskStatesResponse>(Arena*);
template<> ::tapdata::MessageHeader* Arena::CreateMaybeMessage<::tapdata::MessageHeader>(Arena*);
template<> ::tapdata::PingRequest* Arena::CreateMaybeMessage<::tapdata::PingRequest>(Arena*);
template<> ::tapdata::PingResponse* Arena::CreateMaybeMessage<::tapdata::PingResponse>(Arena*);
template<> ::tapdata::PushReadLogRequest* Arena::CreateMaybeMessage<::tapdata::PushReadLogRequest>(Arena*);
template<> ::tapdata::PushReadLogResponse* Arena::CreateMaybeMessage<::tapdata::PushReadLogResponse>(Arena*);
template<> ::tapdata::ReadLogPayload* Arena::CreateMaybeMessage<::tapdata::ReadLogPayload>(Arena*);
template<> ::tapdata::ReadLogRequest* Arena::CreateMaybeMessage<::tapdata::ReadLogRequest>(Arena*);
template<> ::tapdata::ReadLogResponse* Arena::CreateMaybeMessage<::tapdata::ReadLogResponse>(Arena*);
template<> ::tapdata::ReadLogTaskState* Arena::CreateMaybeMessage<::tapdata::ReadLogTaskState>(Arena*);
template<> ::tapdata::ReaderSource* Arena::CreateMaybeMessage<::tapdata::ReaderSource>(Arena*);
template<> ::tapdata::ServerInfoResponse* Arena::CreateMaybeMessage<::tapdata::ServerInfoResponse>(Arena*);
template<> ::tapdata::SourceTable* Arena::CreateMaybeMessage<::tapdata::SourceTable>(Arena*);
template<> ::tapdata::TaskHandleRequest* Arena::CreateMaybeMessage<::tapdata::TaskHandleRequest>(Arena*);
template<> ::tapdata::WriterTarget* Arena::CreateMaybeMessage<::tapdata::WriterTarget>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tapdata {

enum WriterType : int {
  GRPC = 0,
  KAFKA = 1,
  WriterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WriterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WriterType_IsValid(int value);
constexpr WriterType WriterType_MIN = GRPC;
constexpr WriterType WriterType_MAX = KAFKA;
constexpr int WriterType_ARRAYSIZE = WriterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WriterType_descriptor();
template<typename T>
inline const std::string& WriterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WriterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WriterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WriterType_descriptor(), enum_t_value);
}
inline bool WriterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WriterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WriterType>(
    WriterType_descriptor(), name, value);
}
enum DB2Veresion : int {
  AUTO = 0,
  V9 = 1,
  V10 = 2,
  DB2Veresion_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DB2Veresion_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DB2Veresion_IsValid(int value);
constexpr DB2Veresion DB2Veresion_MIN = AUTO;
constexpr DB2Veresion DB2Veresion_MAX = V10;
constexpr int DB2Veresion_ARRAYSIZE = DB2Veresion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DB2Veresion_descriptor();
template<typename T>
inline const std::string& DB2Veresion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DB2Veresion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DB2Veresion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DB2Veresion_descriptor(), enum_t_value);
}
inline bool DB2Veresion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DB2Veresion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DB2Veresion>(
    DB2Veresion_descriptor(), name, value);
}
enum ResponseCode : int {
  OK = 0,
  INVALID_PARAM = 1,
  ALREADY_CREATE = 2,
  NOT_EXIST = 3,
  PAUSED = 4,
  RUNNING = 5,
  STOP_BY_EXCEPTION = 6,
  NOT_SUPPORT = 7,
  SHUTTING_DOWN = 8,
  PASSIVE_STOP = 9,
  ResponseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResponseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResponseCode_IsValid(int value);
constexpr ResponseCode ResponseCode_MIN = OK;
constexpr ResponseCode ResponseCode_MAX = PASSIVE_STOP;
constexpr int ResponseCode_ARRAYSIZE = ResponseCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseCode_descriptor();
template<typename T>
inline const std::string& ResponseCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseCode_descriptor(), enum_t_value);
}
inline bool ResponseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseCode>(
    ResponseCode_descriptor(), name, value);
}
enum TaskState : int {
  TASK_RUNNING = 0,
  TASK_PAUSED = 1,
  TASK_STOP_BY_EXCEPTION = 2,
  TaskState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskState_IsValid(int value);
constexpr TaskState TaskState_MIN = TASK_RUNNING;
constexpr TaskState TaskState_MAX = TASK_STOP_BY_EXCEPTION;
constexpr int TaskState_ARRAYSIZE = TaskState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskState_descriptor();
template<typename T>
inline const std::string& TaskState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskState_descriptor(), enum_t_value);
}
inline bool TaskState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskState>(
    TaskState_descriptor(), name, value);
}
enum ReadLogOp : int {
  UNKNOWN = 0,
  ROLLBACK = 1,
  COMMIT = 2,
  INSERT = 3,
  UPDATE = 4,
  DELETE = 5,
  DDL = 6,
  ReadLogOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ReadLogOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ReadLogOp_IsValid(int value);
constexpr ReadLogOp ReadLogOp_MIN = UNKNOWN;
constexpr ReadLogOp ReadLogOp_MAX = DDL;
constexpr int ReadLogOp_ARRAYSIZE = ReadLogOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReadLogOp_descriptor();
template<typename T>
inline const std::string& ReadLogOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReadLogOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReadLogOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReadLogOp_descriptor(), enum_t_value);
}
inline bool ReadLogOp_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReadLogOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReadLogOp>(
    ReadLogOp_descriptor(), name, value);
}
enum PushResponseCode : int {
  PUSH_OK = 0,
  PUSH_STOP = 1,
  PUSH_PAUSED = 2,
  PushResponseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PushResponseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PushResponseCode_IsValid(int value);
constexpr PushResponseCode PushResponseCode_MIN = PUSH_OK;
constexpr PushResponseCode PushResponseCode_MAX = PUSH_PAUSED;
constexpr int PushResponseCode_ARRAYSIZE = PushResponseCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PushResponseCode_descriptor();
template<typename T>
inline const std::string& PushResponseCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PushResponseCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PushResponseCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PushResponseCode_descriptor(), enum_t_value);
}
inline bool PushResponseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PushResponseCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PushResponseCode>(
    PushResponseCode_descriptor(), name, value);
}
// ===================================================================

class MessageHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.MessageHeader) */ {
 public:
  inline MessageHeader() : MessageHeader(nullptr) {}
  ~MessageHeader() override;
  explicit constexpr MessageHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageHeader(const MessageHeader& from);
  MessageHeader(MessageHeader&& from) noexcept
    : MessageHeader() {
    *this = ::std::move(from);
  }

  inline MessageHeader& operator=(const MessageHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageHeader& operator=(MessageHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageHeader* internal_default_instance() {
    return reinterpret_cast<const MessageHeader*>(
               &_MessageHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MessageHeader& a, MessageHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageHeader* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageHeader* New() const final {
    return new MessageHeader();
  }

  MessageHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MessageHeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.MessageHeader";
  }
  protected:
  explicit MessageHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtocolVersionFieldNumber = 1,
  };
  // int32 ProtocolVersion = 1;
  void clear_protocolversion();
  ::PROTOBUF_NAMESPACE_ID::int32 protocolversion() const;
  void set_protocolversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_protocolversion() const;
  void _internal_set_protocolversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.MessageHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 protocolversion_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class PingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  ~PingRequest() override;
  explicit constexpr PingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingRequest(const PingRequest& from);
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingRequest* New() const final {
    return new PingRequest();
  }

  PingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PingRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.PingRequest";
  }
  protected:
  explicit PingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // .tapdata.MessageHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tapdata::MessageHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::MessageHeader* release_header();
  ::tapdata::MessageHeader* mutable_header();
  void set_allocated_header(::tapdata::MessageHeader* header);
  private:
  const ::tapdata::MessageHeader& _internal_header() const;
  ::tapdata::MessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tapdata::MessageHeader* header);
  ::tapdata::MessageHeader* unsafe_arena_release_header();

  // int32 code = 2;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.PingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tapdata::MessageHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class PingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.PingResponse) */ {
 public:
  inline PingResponse() : PingResponse(nullptr) {}
  ~PingResponse() override;
  explicit constexpr PingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingResponse(const PingResponse& from);
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PingResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingResponse* New() const final {
    return new PingResponse();
  }

  PingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PingResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.PingResponse";
  }
  protected:
  explicit PingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string msg = 3;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .tapdata.MessageHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tapdata::MessageHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::MessageHeader* release_header();
  ::tapdata::MessageHeader* mutable_header();
  void set_allocated_header(::tapdata::MessageHeader* header);
  private:
  const ::tapdata::MessageHeader& _internal_header() const;
  ::tapdata::MessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tapdata::MessageHeader* header);
  ::tapdata::MessageHeader* unsafe_arena_release_header();

  // int32 status = 2;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.PingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::tapdata::MessageHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class ServerInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.ServerInfoResponse) */ {
 public:
  inline ServerInfoResponse() : ServerInfoResponse(nullptr) {}
  ~ServerInfoResponse() override;
  explicit constexpr ServerInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfoResponse(const ServerInfoResponse& from);
  ServerInfoResponse(ServerInfoResponse&& from) noexcept
    : ServerInfoResponse() {
    *this = ::std::move(from);
  }

  inline ServerInfoResponse& operator=(const ServerInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfoResponse& operator=(ServerInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfoResponse* internal_default_instance() {
    return reinterpret_cast<const ServerInfoResponse*>(
               &_ServerInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ServerInfoResponse& a, ServerInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerInfoResponse* New() const final {
    return new ServerInfoResponse();
  }

  ServerInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.ServerInfoResponse";
  }
  protected:
  explicit ServerInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportProtocolVersionFieldNumber = 5,
    kSupportWriterTypeFieldNumber = 6,
    kInfoFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kServerVersionFieldNumber = 2,
    kSupportVersionFieldNumber = 4,
  };
  // repeated int32 supportProtocolVersion = 5;
  int supportprotocolversion_size() const;
  private:
  int _internal_supportprotocolversion_size() const;
  public:
  void clear_supportprotocolversion();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_supportprotocolversion(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_supportprotocolversion() const;
  void _internal_add_supportprotocolversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_supportprotocolversion();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 supportprotocolversion(int index) const;
  void set_supportprotocolversion(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_supportprotocolversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      supportprotocolversion() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_supportprotocolversion();

  // repeated .tapdata.WriterType supportWriterType = 6;
  int supportwritertype_size() const;
  private:
  int _internal_supportwritertype_size() const;
  public:
  void clear_supportwritertype();
  private:
  ::tapdata::WriterType _internal_supportwritertype(int index) const;
  void _internal_add_supportwritertype(::tapdata::WriterType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supportwritertype();
  public:
  ::tapdata::WriterType supportwritertype(int index) const;
  void set_supportwritertype(int index, ::tapdata::WriterType value);
  void add_supportwritertype(::tapdata::WriterType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supportwritertype() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supportwritertype();

  // string info = 3;
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_MUST_USE_RESULT std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // .tapdata.MessageHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tapdata::MessageHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::MessageHeader* release_header();
  ::tapdata::MessageHeader* mutable_header();
  void set_allocated_header(::tapdata::MessageHeader* header);
  private:
  const ::tapdata::MessageHeader& _internal_header() const;
  ::tapdata::MessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tapdata::MessageHeader* header);
  ::tapdata::MessageHeader* unsafe_arena_release_header();

  // int32 serverVersion = 2;
  void clear_serverversion();
  ::PROTOBUF_NAMESPACE_ID::int32 serverversion() const;
  void set_serverversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_serverversion() const;
  void _internal_set_serverversion(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .tapdata.DB2Veresion supportVersion = 4;
  void clear_supportversion();
  ::tapdata::DB2Veresion supportversion() const;
  void set_supportversion(::tapdata::DB2Veresion value);
  private:
  ::tapdata::DB2Veresion _internal_supportversion() const;
  void _internal_set_supportversion(::tapdata::DB2Veresion value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.ServerInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > supportprotocolversion_;
  mutable std::atomic<int> _supportprotocolversion_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supportwritertype_;
  mutable std::atomic<int> _supportwritertype_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  ::tapdata::MessageHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::int32 serverversion_;
  int supportversion_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class ReaderSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.ReaderSource) */ {
 public:
  inline ReaderSource() : ReaderSource(nullptr) {}
  ~ReaderSource() override;
  explicit constexpr ReaderSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReaderSource(const ReaderSource& from);
  ReaderSource(ReaderSource&& from) noexcept
    : ReaderSource() {
    *this = ::std::move(from);
  }

  inline ReaderSource& operator=(const ReaderSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReaderSource& operator=(ReaderSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReaderSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReaderSource* internal_default_instance() {
    return reinterpret_cast<const ReaderSource*>(
               &_ReaderSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReaderSource& a, ReaderSource& b) {
    a.Swap(&b);
  }
  inline void Swap(ReaderSource* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReaderSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReaderSource* New() const final {
    return new ReaderSource();
  }

  ReaderSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReaderSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReaderSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReaderSource& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReaderSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.ReaderSource";
  }
  protected:
  explicit ReaderSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseNameFieldNumber = 2,
    kDatabaseUsernameFieldNumber = 3,
    kDatabasePasswordFieldNumber = 4,
    kDatabaseHostnameFieldNumber = 5,
    kDatabaseServiceNameFieldNumber = 6,
    kDatabaseVersionFieldNumber = 1,
  };
  // string databaseName = 2;
  void clear_databasename();
  const std::string& databasename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_databasename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_databasename();
  PROTOBUF_MUST_USE_RESULT std::string* release_databasename();
  void set_allocated_databasename(std::string* databasename);
  private:
  const std::string& _internal_databasename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_databasename(const std::string& value);
  std::string* _internal_mutable_databasename();
  public:

  // string databaseUsername = 3;
  void clear_databaseusername();
  const std::string& databaseusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_databaseusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_databaseusername();
  PROTOBUF_MUST_USE_RESULT std::string* release_databaseusername();
  void set_allocated_databaseusername(std::string* databaseusername);
  private:
  const std::string& _internal_databaseusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_databaseusername(const std::string& value);
  std::string* _internal_mutable_databaseusername();
  public:

  // string databasePassword = 4;
  void clear_databasepassword();
  const std::string& databasepassword() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_databasepassword(ArgT0&& arg0, ArgT... args);
  std::string* mutable_databasepassword();
  PROTOBUF_MUST_USE_RESULT std::string* release_databasepassword();
  void set_allocated_databasepassword(std::string* databasepassword);
  private:
  const std::string& _internal_databasepassword() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_databasepassword(const std::string& value);
  std::string* _internal_mutable_databasepassword();
  public:

  // string databaseHostname = 5;
  void clear_databasehostname();
  const std::string& databasehostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_databasehostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_databasehostname();
  PROTOBUF_MUST_USE_RESULT std::string* release_databasehostname();
  void set_allocated_databasehostname(std::string* databasehostname);
  private:
  const std::string& _internal_databasehostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_databasehostname(const std::string& value);
  std::string* _internal_mutable_databasehostname();
  public:

  // string databaseServiceName = 6;
  void clear_databaseservicename();
  const std::string& databaseservicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_databaseservicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_databaseservicename();
  PROTOBUF_MUST_USE_RESULT std::string* release_databaseservicename();
  void set_allocated_databaseservicename(std::string* databaseservicename);
  private:
  const std::string& _internal_databaseservicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_databaseservicename(const std::string& value);
  std::string* _internal_mutable_databaseservicename();
  public:

  // .tapdata.DB2Veresion databaseVersion = 1;
  void clear_databaseversion();
  ::tapdata::DB2Veresion databaseversion() const;
  void set_databaseversion(::tapdata::DB2Veresion value);
  private:
  ::tapdata::DB2Veresion _internal_databaseversion() const;
  void _internal_set_databaseversion(::tapdata::DB2Veresion value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.ReaderSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr databasename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr databaseusername_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr databasepassword_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr databasehostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr databaseservicename_;
  int databaseversion_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class WriterTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.WriterTarget) */ {
 public:
  inline WriterTarget() : WriterTarget(nullptr) {}
  ~WriterTarget() override;
  explicit constexpr WriterTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriterTarget(const WriterTarget& from);
  WriterTarget(WriterTarget&& from) noexcept
    : WriterTarget() {
    *this = ::std::move(from);
  }

  inline WriterTarget& operator=(const WriterTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriterTarget& operator=(WriterTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriterTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriterTarget* internal_default_instance() {
    return reinterpret_cast<const WriterTarget*>(
               &_WriterTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WriterTarget& a, WriterTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(WriterTarget* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriterTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WriterTarget* New() const final {
    return new WriterTarget();
  }

  WriterTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WriterTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriterTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriterTarget& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriterTarget* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.WriterTarget";
  }
  protected:
  explicit WriterTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKafkaWriterTopicFieldNumber = 2,
    kKafkaWriterBrokersFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // string kafkaWriterTopic = 2;
  void clear_kafkawritertopic();
  const std::string& kafkawritertopic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kafkawritertopic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kafkawritertopic();
  PROTOBUF_MUST_USE_RESULT std::string* release_kafkawritertopic();
  void set_allocated_kafkawritertopic(std::string* kafkawritertopic);
  private:
  const std::string& _internal_kafkawritertopic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kafkawritertopic(const std::string& value);
  std::string* _internal_mutable_kafkawritertopic();
  public:

  // string kafkaWriterBrokers = 3;
  void clear_kafkawriterbrokers();
  const std::string& kafkawriterbrokers() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kafkawriterbrokers(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kafkawriterbrokers();
  PROTOBUF_MUST_USE_RESULT std::string* release_kafkawriterbrokers();
  void set_allocated_kafkawriterbrokers(std::string* kafkawriterbrokers);
  private:
  const std::string& _internal_kafkawriterbrokers() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kafkawriterbrokers(const std::string& value);
  std::string* _internal_mutable_kafkawriterbrokers();
  public:

  // .tapdata.WriterType type = 1;
  void clear_type();
  ::tapdata::WriterType type() const;
  void set_type(::tapdata::WriterType value);
  private:
  ::tapdata::WriterType _internal_type() const;
  void _internal_set_type(::tapdata::WriterType value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.WriterTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kafkawritertopic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kafkawriterbrokers_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class SourceTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.SourceTable) */ {
 public:
  inline SourceTable() : SourceTable(nullptr) {}
  ~SourceTable() override;
  explicit constexpr SourceTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SourceTable(const SourceTable& from);
  SourceTable(SourceTable&& from) noexcept
    : SourceTable() {
    *this = ::std::move(from);
  }

  inline SourceTable& operator=(const SourceTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceTable& operator=(SourceTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SourceTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourceTable* internal_default_instance() {
    return reinterpret_cast<const SourceTable*>(
               &_SourceTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SourceTable& a, SourceTable& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceTable* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SourceTable* New() const final {
    return new SourceTable();
  }

  SourceTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SourceTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SourceTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SourceTable& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceTable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.SourceTable";
  }
  protected:
  explicit SourceTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
    kTableSpaceIdFieldNumber = 2,
  };
  // int32 tableId = 1;
  void clear_tableid();
  ::PROTOBUF_NAMESPACE_ID::int32 tableid() const;
  void set_tableid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tableid() const;
  void _internal_set_tableid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 tableSpaceId = 2;
  void clear_tablespaceid();
  ::PROTOBUF_NAMESPACE_ID::int32 tablespaceid() const;
  void set_tablespaceid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tablespaceid() const;
  void _internal_set_tablespaceid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.SourceTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 tableid_;
  ::PROTOBUF_NAMESPACE_ID::int32 tablespaceid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class ReadLogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.ReadLogRequest) */ {
 public:
  inline ReadLogRequest() : ReadLogRequest(nullptr) {}
  ~ReadLogRequest() override;
  explicit constexpr ReadLogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadLogRequest(const ReadLogRequest& from);
  ReadLogRequest(ReadLogRequest&& from) noexcept
    : ReadLogRequest() {
    *this = ::std::move(from);
  }

  inline ReadLogRequest& operator=(const ReadLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadLogRequest& operator=(ReadLogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadLogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadLogRequest* internal_default_instance() {
    return reinterpret_cast<const ReadLogRequest*>(
               &_ReadLogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReadLogRequest& a, ReadLogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadLogRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadLogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadLogRequest* New() const final {
    return new ReadLogRequest();
  }

  ReadLogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadLogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadLogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadLogRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadLogRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.ReadLogRequest";
  }
  protected:
  explicit ReadLogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTablesFieldNumber = 6,
    kIdFieldNumber = 3,
    kScnFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kSourceFieldNumber = 7,
    kTargetFieldNumber = 8,
    kStimeFieldNumber = 5,
    kBigEndianFieldNumber = 2,
  };
  // repeated .tapdata.SourceTable tables = 6;
  int tables_size() const;
  private:
  int _internal_tables_size() const;
  public:
  void clear_tables();
  ::tapdata::SourceTable* mutable_tables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::SourceTable >*
      mutable_tables();
  private:
  const ::tapdata::SourceTable& _internal_tables(int index) const;
  ::tapdata::SourceTable* _internal_add_tables();
  public:
  const ::tapdata::SourceTable& tables(int index) const;
  ::tapdata::SourceTable* add_tables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::SourceTable >&
      tables() const;

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string scn = 4;
  void clear_scn();
  const std::string& scn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scn();
  PROTOBUF_MUST_USE_RESULT std::string* release_scn();
  void set_allocated_scn(std::string* scn);
  private:
  const std::string& _internal_scn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scn(const std::string& value);
  std::string* _internal_mutable_scn();
  public:

  // .tapdata.MessageHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tapdata::MessageHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::MessageHeader* release_header();
  ::tapdata::MessageHeader* mutable_header();
  void set_allocated_header(::tapdata::MessageHeader* header);
  private:
  const ::tapdata::MessageHeader& _internal_header() const;
  ::tapdata::MessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tapdata::MessageHeader* header);
  ::tapdata::MessageHeader* unsafe_arena_release_header();

  // .tapdata.ReaderSource source = 7;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::tapdata::ReaderSource& source() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::ReaderSource* release_source();
  ::tapdata::ReaderSource* mutable_source();
  void set_allocated_source(::tapdata::ReaderSource* source);
  private:
  const ::tapdata::ReaderSource& _internal_source() const;
  ::tapdata::ReaderSource* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::tapdata::ReaderSource* source);
  ::tapdata::ReaderSource* unsafe_arena_release_source();

  // .tapdata.WriterTarget target = 8;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::tapdata::WriterTarget& target() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::WriterTarget* release_target();
  ::tapdata::WriterTarget* mutable_target();
  void set_allocated_target(::tapdata::WriterTarget* target);
  private:
  const ::tapdata::WriterTarget& _internal_target() const;
  ::tapdata::WriterTarget* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::tapdata::WriterTarget* target);
  ::tapdata::WriterTarget* unsafe_arena_release_target();

  // int64 stime = 5;
  void clear_stime();
  ::PROTOBUF_NAMESPACE_ID::int64 stime() const;
  void set_stime(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_stime() const;
  void _internal_set_stime(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool bigEndian = 2;
  void clear_bigendian();
  bool bigendian() const;
  void set_bigendian(bool value);
  private:
  bool _internal_bigendian() const;
  void _internal_set_bigendian(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.ReadLogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::SourceTable > tables_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scn_;
  ::tapdata::MessageHeader* header_;
  ::tapdata::ReaderSource* source_;
  ::tapdata::WriterTarget* target_;
  ::PROTOBUF_NAMESPACE_ID::int64 stime_;
  bool bigendian_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class TaskHandleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.TaskHandleRequest) */ {
 public:
  inline TaskHandleRequest() : TaskHandleRequest(nullptr) {}
  ~TaskHandleRequest() override;
  explicit constexpr TaskHandleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskHandleRequest(const TaskHandleRequest& from);
  TaskHandleRequest(TaskHandleRequest&& from) noexcept
    : TaskHandleRequest() {
    *this = ::std::move(from);
  }

  inline TaskHandleRequest& operator=(const TaskHandleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskHandleRequest& operator=(TaskHandleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskHandleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskHandleRequest* internal_default_instance() {
    return reinterpret_cast<const TaskHandleRequest*>(
               &_TaskHandleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TaskHandleRequest& a, TaskHandleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskHandleRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskHandleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskHandleRequest* New() const final {
    return new TaskHandleRequest();
  }

  TaskHandleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskHandleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskHandleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskHandleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskHandleRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.TaskHandleRequest";
  }
  protected:
  explicit TaskHandleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .tapdata.MessageHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tapdata::MessageHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::MessageHeader* release_header();
  ::tapdata::MessageHeader* mutable_header();
  void set_allocated_header(::tapdata::MessageHeader* header);
  private:
  const ::tapdata::MessageHeader& _internal_header() const;
  ::tapdata::MessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tapdata::MessageHeader* header);
  ::tapdata::MessageHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:tapdata.TaskHandleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::tapdata::MessageHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class ControlResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.ControlResponse) */ {
 public:
  inline ControlResponse() : ControlResponse(nullptr) {}
  ~ControlResponse() override;
  explicit constexpr ControlResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlResponse(const ControlResponse& from);
  ControlResponse(ControlResponse&& from) noexcept
    : ControlResponse() {
    *this = ::std::move(from);
  }

  inline ControlResponse& operator=(const ControlResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlResponse& operator=(ControlResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlResponse* internal_default_instance() {
    return reinterpret_cast<const ControlResponse*>(
               &_ControlResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ControlResponse& a, ControlResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlResponse* New() const final {
    return new ControlResponse();
  }

  ControlResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.ControlResponse";
  }
  protected:
  explicit ControlResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // string msg = 3;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .tapdata.MessageHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tapdata::MessageHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::MessageHeader* release_header();
  ::tapdata::MessageHeader* mutable_header();
  void set_allocated_header(::tapdata::MessageHeader* header);
  private:
  const ::tapdata::MessageHeader& _internal_header() const;
  ::tapdata::MessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tapdata::MessageHeader* header);
  ::tapdata::MessageHeader* unsafe_arena_release_header();

  // .tapdata.ResponseCode code = 2;
  void clear_code();
  ::tapdata::ResponseCode code() const;
  void set_code(::tapdata::ResponseCode value);
  private:
  ::tapdata::ResponseCode _internal_code() const;
  void _internal_set_code(::tapdata::ResponseCode value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.ControlResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::tapdata::MessageHeader* header_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class ReadLogTaskState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.ReadLogTaskState) */ {
 public:
  inline ReadLogTaskState() : ReadLogTaskState(nullptr) {}
  ~ReadLogTaskState() override;
  explicit constexpr ReadLogTaskState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadLogTaskState(const ReadLogTaskState& from);
  ReadLogTaskState(ReadLogTaskState&& from) noexcept
    : ReadLogTaskState() {
    *this = ::std::move(from);
  }

  inline ReadLogTaskState& operator=(const ReadLogTaskState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadLogTaskState& operator=(ReadLogTaskState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadLogTaskState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadLogTaskState* internal_default_instance() {
    return reinterpret_cast<const ReadLogTaskState*>(
               &_ReadLogTaskState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ReadLogTaskState& a, ReadLogTaskState& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadLogTaskState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadLogTaskState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadLogTaskState* New() const final {
    return new ReadLogTaskState();
  }

  ReadLogTaskState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadLogTaskState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadLogTaskState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadLogTaskState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadLogTaskState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.ReadLogTaskState";
  }
  protected:
  explicit ReadLogTaskState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .tapdata.TaskState state = 2;
  void clear_state();
  ::tapdata::TaskState state() const;
  void set_state(::tapdata::TaskState value);
  private:
  ::tapdata::TaskState _internal_state() const;
  void _internal_set_state(::tapdata::TaskState value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.ReadLogTaskState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class ListReadLogTaskStatesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.ListReadLogTaskStatesRequest) */ {
 public:
  inline ListReadLogTaskStatesRequest() : ListReadLogTaskStatesRequest(nullptr) {}
  ~ListReadLogTaskStatesRequest() override;
  explicit constexpr ListReadLogTaskStatesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListReadLogTaskStatesRequest(const ListReadLogTaskStatesRequest& from);
  ListReadLogTaskStatesRequest(ListReadLogTaskStatesRequest&& from) noexcept
    : ListReadLogTaskStatesRequest() {
    *this = ::std::move(from);
  }

  inline ListReadLogTaskStatesRequest& operator=(const ListReadLogTaskStatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListReadLogTaskStatesRequest& operator=(ListReadLogTaskStatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListReadLogTaskStatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListReadLogTaskStatesRequest* internal_default_instance() {
    return reinterpret_cast<const ListReadLogTaskStatesRequest*>(
               &_ListReadLogTaskStatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListReadLogTaskStatesRequest& a, ListReadLogTaskStatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListReadLogTaskStatesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListReadLogTaskStatesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListReadLogTaskStatesRequest* New() const final {
    return new ListReadLogTaskStatesRequest();
  }

  ListReadLogTaskStatesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListReadLogTaskStatesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListReadLogTaskStatesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListReadLogTaskStatesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListReadLogTaskStatesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.ListReadLogTaskStatesRequest";
  }
  protected:
  explicit ListReadLogTaskStatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .tapdata.MessageHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tapdata::MessageHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::MessageHeader* release_header();
  ::tapdata::MessageHeader* mutable_header();
  void set_allocated_header(::tapdata::MessageHeader* header);
  private:
  const ::tapdata::MessageHeader& _internal_header() const;
  ::tapdata::MessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tapdata::MessageHeader* header);
  ::tapdata::MessageHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:tapdata.ListReadLogTaskStatesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tapdata::MessageHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class ListReadLogTaskStatesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.ListReadLogTaskStatesResponse) */ {
 public:
  inline ListReadLogTaskStatesResponse() : ListReadLogTaskStatesResponse(nullptr) {}
  ~ListReadLogTaskStatesResponse() override;
  explicit constexpr ListReadLogTaskStatesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListReadLogTaskStatesResponse(const ListReadLogTaskStatesResponse& from);
  ListReadLogTaskStatesResponse(ListReadLogTaskStatesResponse&& from) noexcept
    : ListReadLogTaskStatesResponse() {
    *this = ::std::move(from);
  }

  inline ListReadLogTaskStatesResponse& operator=(const ListReadLogTaskStatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListReadLogTaskStatesResponse& operator=(ListReadLogTaskStatesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListReadLogTaskStatesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListReadLogTaskStatesResponse* internal_default_instance() {
    return reinterpret_cast<const ListReadLogTaskStatesResponse*>(
               &_ListReadLogTaskStatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListReadLogTaskStatesResponse& a, ListReadLogTaskStatesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListReadLogTaskStatesResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListReadLogTaskStatesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListReadLogTaskStatesResponse* New() const final {
    return new ListReadLogTaskStatesResponse();
  }

  ListReadLogTaskStatesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListReadLogTaskStatesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListReadLogTaskStatesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListReadLogTaskStatesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListReadLogTaskStatesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.ListReadLogTaskStatesResponse";
  }
  protected:
  explicit ListReadLogTaskStatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskStateFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // repeated .tapdata.ReadLogTaskState taskState = 3;
  int taskstate_size() const;
  private:
  int _internal_taskstate_size() const;
  public:
  void clear_taskstate();
  ::tapdata::ReadLogTaskState* mutable_taskstate(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogTaskState >*
      mutable_taskstate();
  private:
  const ::tapdata::ReadLogTaskState& _internal_taskstate(int index) const;
  ::tapdata::ReadLogTaskState* _internal_add_taskstate();
  public:
  const ::tapdata::ReadLogTaskState& taskstate(int index) const;
  ::tapdata::ReadLogTaskState* add_taskstate();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogTaskState >&
      taskstate() const;

  // .tapdata.MessageHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tapdata::MessageHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::MessageHeader* release_header();
  ::tapdata::MessageHeader* mutable_header();
  void set_allocated_header(::tapdata::MessageHeader* header);
  private:
  const ::tapdata::MessageHeader& _internal_header() const;
  ::tapdata::MessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tapdata::MessageHeader* header);
  ::tapdata::MessageHeader* unsafe_arena_release_header();

  // .tapdata.ResponseCode code = 2;
  void clear_code();
  ::tapdata::ResponseCode code() const;
  void set_code(::tapdata::ResponseCode value);
  private:
  ::tapdata::ResponseCode _internal_code() const;
  void _internal_set_code(::tapdata::ResponseCode value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.ListReadLogTaskStatesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogTaskState > taskstate_;
  ::tapdata::MessageHeader* header_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class GetReadLogTaskStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.GetReadLogTaskStateResponse) */ {
 public:
  inline GetReadLogTaskStateResponse() : GetReadLogTaskStateResponse(nullptr) {}
  ~GetReadLogTaskStateResponse() override;
  explicit constexpr GetReadLogTaskStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetReadLogTaskStateResponse(const GetReadLogTaskStateResponse& from);
  GetReadLogTaskStateResponse(GetReadLogTaskStateResponse&& from) noexcept
    : GetReadLogTaskStateResponse() {
    *this = ::std::move(from);
  }

  inline GetReadLogTaskStateResponse& operator=(const GetReadLogTaskStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetReadLogTaskStateResponse& operator=(GetReadLogTaskStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetReadLogTaskStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetReadLogTaskStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetReadLogTaskStateResponse*>(
               &_GetReadLogTaskStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetReadLogTaskStateResponse& a, GetReadLogTaskStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetReadLogTaskStateResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetReadLogTaskStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetReadLogTaskStateResponse* New() const final {
    return new GetReadLogTaskStateResponse();
  }

  GetReadLogTaskStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetReadLogTaskStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetReadLogTaskStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetReadLogTaskStateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetReadLogTaskStateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.GetReadLogTaskStateResponse";
  }
  protected:
  explicit GetReadLogTaskStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskStateFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // repeated .tapdata.ReadLogTaskState taskState = 3;
  int taskstate_size() const;
  private:
  int _internal_taskstate_size() const;
  public:
  void clear_taskstate();
  ::tapdata::ReadLogTaskState* mutable_taskstate(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogTaskState >*
      mutable_taskstate();
  private:
  const ::tapdata::ReadLogTaskState& _internal_taskstate(int index) const;
  ::tapdata::ReadLogTaskState* _internal_add_taskstate();
  public:
  const ::tapdata::ReadLogTaskState& taskstate(int index) const;
  ::tapdata::ReadLogTaskState* add_taskstate();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogTaskState >&
      taskstate() const;

  // .tapdata.MessageHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tapdata::MessageHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::MessageHeader* release_header();
  ::tapdata::MessageHeader* mutable_header();
  void set_allocated_header(::tapdata::MessageHeader* header);
  private:
  const ::tapdata::MessageHeader& _internal_header() const;
  ::tapdata::MessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tapdata::MessageHeader* header);
  ::tapdata::MessageHeader* unsafe_arena_release_header();

  // .tapdata.ResponseCode code = 2;
  void clear_code();
  ::tapdata::ResponseCode code() const;
  void set_code(::tapdata::ResponseCode value);
  private:
  ::tapdata::ResponseCode _internal_code() const;
  void _internal_set_code(::tapdata::ResponseCode value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.GetReadLogTaskStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogTaskState > taskstate_;
  ::tapdata::MessageHeader* header_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class ReadLogPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.ReadLogPayload) */ {
 public:
  inline ReadLogPayload() : ReadLogPayload(nullptr) {}
  ~ReadLogPayload() override;
  explicit constexpr ReadLogPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadLogPayload(const ReadLogPayload& from);
  ReadLogPayload(ReadLogPayload&& from) noexcept
    : ReadLogPayload() {
    *this = ::std::move(from);
  }

  inline ReadLogPayload& operator=(const ReadLogPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadLogPayload& operator=(ReadLogPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadLogPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadLogPayload* internal_default_instance() {
    return reinterpret_cast<const ReadLogPayload*>(
               &_ReadLogPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReadLogPayload& a, ReadLogPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadLogPayload* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadLogPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadLogPayload* New() const final {
    return new ReadLogPayload();
  }

  ReadLogPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadLogPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadLogPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadLogPayload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadLogPayload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.ReadLogPayload";
  }
  protected:
  explicit ReadLogPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScnFieldNumber = 2,
    kLogBytesFieldNumber = 3,
    kTransactionIdFieldNumber = 5,
    kRidFieldNumber = 8,
    kDefaultSchemaFieldNumber = 9,
    kSchemaFieldNumber = 10,
    kTableNameFieldNumber = 11,
    kBeforeLogBytesFieldNumber = 12,
    kPendingMinScnFieldNumber = 13,
    kOpFieldNumber = 1,
    kTableIdFieldNumber = 6,
    kTransactionTimeFieldNumber = 4,
    kTableSpaceIdFieldNumber = 7,
  };
  // string scn = 2;
  void clear_scn();
  const std::string& scn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scn();
  PROTOBUF_MUST_USE_RESULT std::string* release_scn();
  void set_allocated_scn(std::string* scn);
  private:
  const std::string& _internal_scn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scn(const std::string& value);
  std::string* _internal_mutable_scn();
  public:

  // bytes logBytes = 3;
  void clear_logbytes();
  const std::string& logbytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logbytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logbytes();
  PROTOBUF_MUST_USE_RESULT std::string* release_logbytes();
  void set_allocated_logbytes(std::string* logbytes);
  private:
  const std::string& _internal_logbytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logbytes(const std::string& value);
  std::string* _internal_mutable_logbytes();
  public:

  // string transactionId = 5;
  void clear_transactionid();
  const std::string& transactionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transactionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transactionid();
  PROTOBUF_MUST_USE_RESULT std::string* release_transactionid();
  void set_allocated_transactionid(std::string* transactionid);
  private:
  const std::string& _internal_transactionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transactionid(const std::string& value);
  std::string* _internal_mutable_transactionid();
  public:

  // string rid = 8;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_MUST_USE_RESULT std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // string defaultSchema = 9;
  void clear_defaultschema();
  const std::string& defaultschema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_defaultschema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_defaultschema();
  PROTOBUF_MUST_USE_RESULT std::string* release_defaultschema();
  void set_allocated_defaultschema(std::string* defaultschema);
  private:
  const std::string& _internal_defaultschema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_defaultschema(const std::string& value);
  std::string* _internal_mutable_defaultschema();
  public:

  // string schema = 10;
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_MUST_USE_RESULT std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // string tableName = 11;
  void clear_tablename();
  const std::string& tablename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tablename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tablename();
  PROTOBUF_MUST_USE_RESULT std::string* release_tablename();
  void set_allocated_tablename(std::string* tablename);
  private:
  const std::string& _internal_tablename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tablename(const std::string& value);
  std::string* _internal_mutable_tablename();
  public:

  // bytes beforeLogBytes = 12;
  void clear_beforelogbytes();
  const std::string& beforelogbytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_beforelogbytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_beforelogbytes();
  PROTOBUF_MUST_USE_RESULT std::string* release_beforelogbytes();
  void set_allocated_beforelogbytes(std::string* beforelogbytes);
  private:
  const std::string& _internal_beforelogbytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_beforelogbytes(const std::string& value);
  std::string* _internal_mutable_beforelogbytes();
  public:

  // string pendingMinScn = 13;
  void clear_pendingminscn();
  const std::string& pendingminscn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pendingminscn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pendingminscn();
  PROTOBUF_MUST_USE_RESULT std::string* release_pendingminscn();
  void set_allocated_pendingminscn(std::string* pendingminscn);
  private:
  const std::string& _internal_pendingminscn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pendingminscn(const std::string& value);
  std::string* _internal_mutable_pendingminscn();
  public:

  // .tapdata.ReadLogOp op = 1;
  void clear_op();
  ::tapdata::ReadLogOp op() const;
  void set_op(::tapdata::ReadLogOp value);
  private:
  ::tapdata::ReadLogOp _internal_op() const;
  void _internal_set_op(::tapdata::ReadLogOp value);
  public:

  // int32 tableId = 6;
  void clear_tableid();
  ::PROTOBUF_NAMESPACE_ID::int32 tableid() const;
  void set_tableid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tableid() const;
  void _internal_set_tableid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 transactionTime = 4;
  void clear_transactiontime();
  ::PROTOBUF_NAMESPACE_ID::int64 transactiontime() const;
  void set_transactiontime(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_transactiontime() const;
  void _internal_set_transactiontime(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 tableSpaceId = 7;
  void clear_tablespaceid();
  ::PROTOBUF_NAMESPACE_ID::int32 tablespaceid() const;
  void set_tablespaceid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tablespaceid() const;
  void _internal_set_tablespaceid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.ReadLogPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logbytes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transactionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr defaultschema_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tablename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr beforelogbytes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pendingminscn_;
  int op_;
  ::PROTOBUF_NAMESPACE_ID::int32 tableid_;
  ::PROTOBUF_NAMESPACE_ID::int64 transactiontime_;
  ::PROTOBUF_NAMESPACE_ID::int32 tablespaceid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class ReadLogResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.ReadLogResponse) */ {
 public:
  inline ReadLogResponse() : ReadLogResponse(nullptr) {}
  ~ReadLogResponse() override;
  explicit constexpr ReadLogResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadLogResponse(const ReadLogResponse& from);
  ReadLogResponse(ReadLogResponse&& from) noexcept
    : ReadLogResponse() {
    *this = ::std::move(from);
  }

  inline ReadLogResponse& operator=(const ReadLogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadLogResponse& operator=(ReadLogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadLogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadLogResponse* internal_default_instance() {
    return reinterpret_cast<const ReadLogResponse*>(
               &_ReadLogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ReadLogResponse& a, ReadLogResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadLogResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadLogResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadLogResponse* New() const final {
    return new ReadLogResponse();
  }

  ReadLogResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadLogResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadLogResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadLogResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadLogResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.ReadLogResponse";
  }
  protected:
  explicit ReadLogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 4,
    kPayloadVersionFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // repeated .tapdata.ReadLogPayload payload = 4;
  int payload_size() const;
  private:
  int _internal_payload_size() const;
  public:
  void clear_payload();
  ::tapdata::ReadLogPayload* mutable_payload(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogPayload >*
      mutable_payload();
  private:
  const ::tapdata::ReadLogPayload& _internal_payload(int index) const;
  ::tapdata::ReadLogPayload* _internal_add_payload();
  public:
  const ::tapdata::ReadLogPayload& payload(int index) const;
  ::tapdata::ReadLogPayload* add_payload();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogPayload >&
      payload() const;

  // string payloadVersion = 3;
  void clear_payloadversion();
  const std::string& payloadversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payloadversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payloadversion();
  PROTOBUF_MUST_USE_RESULT std::string* release_payloadversion();
  void set_allocated_payloadversion(std::string* payloadversion);
  private:
  const std::string& _internal_payloadversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payloadversion(const std::string& value);
  std::string* _internal_mutable_payloadversion();
  public:

  // .tapdata.MessageHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tapdata::MessageHeader& header() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::MessageHeader* release_header();
  ::tapdata::MessageHeader* mutable_header();
  void set_allocated_header(::tapdata::MessageHeader* header);
  private:
  const ::tapdata::MessageHeader& _internal_header() const;
  ::tapdata::MessageHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tapdata::MessageHeader* header);
  ::tapdata::MessageHeader* unsafe_arena_release_header();

  // .tapdata.ResponseCode code = 2;
  void clear_code();
  ::tapdata::ResponseCode code() const;
  void set_code(::tapdata::ResponseCode value);
  private:
  ::tapdata::ResponseCode _internal_code() const;
  void _internal_set_code(::tapdata::ResponseCode value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.ReadLogResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogPayload > payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payloadversion_;
  ::tapdata::MessageHeader* header_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class PushReadLogResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.PushReadLogResponse) */ {
 public:
  inline PushReadLogResponse() : PushReadLogResponse(nullptr) {}
  ~PushReadLogResponse() override;
  explicit constexpr PushReadLogResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushReadLogResponse(const PushReadLogResponse& from);
  PushReadLogResponse(PushReadLogResponse&& from) noexcept
    : PushReadLogResponse() {
    *this = ::std::move(from);
  }

  inline PushReadLogResponse& operator=(const PushReadLogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushReadLogResponse& operator=(PushReadLogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushReadLogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushReadLogResponse* internal_default_instance() {
    return reinterpret_cast<const PushReadLogResponse*>(
               &_PushReadLogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PushReadLogResponse& a, PushReadLogResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PushReadLogResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushReadLogResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PushReadLogResponse* New() const final {
    return new PushReadLogResponse();
  }

  PushReadLogResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PushReadLogResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushReadLogResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PushReadLogResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushReadLogResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.PushReadLogResponse";
  }
  protected:
  explicit PushReadLogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kWaitTimeMSFieldNumber = 2,
  };
  // .tapdata.PushResponseCode code = 1;
  void clear_code();
  ::tapdata::PushResponseCode code() const;
  void set_code(::tapdata::PushResponseCode value);
  private:
  ::tapdata::PushResponseCode _internal_code() const;
  void _internal_set_code(::tapdata::PushResponseCode value);
  public:

  // int32 waitTimeMS = 2;
  void clear_waittimems();
  ::PROTOBUF_NAMESPACE_ID::int32 waittimems() const;
  void set_waittimems(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_waittimems() const;
  void _internal_set_waittimems(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tapdata.PushReadLogResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int code_;
  ::PROTOBUF_NAMESPACE_ID::int32 waittimems_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// -------------------------------------------------------------------

class PushReadLogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tapdata.PushReadLogRequest) */ {
 public:
  inline PushReadLogRequest() : PushReadLogRequest(nullptr) {}
  ~PushReadLogRequest() override;
  explicit constexpr PushReadLogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushReadLogRequest(const PushReadLogRequest& from);
  PushReadLogRequest(PushReadLogRequest&& from) noexcept
    : PushReadLogRequest() {
    *this = ::std::move(from);
  }

  inline PushReadLogRequest& operator=(const PushReadLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushReadLogRequest& operator=(PushReadLogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushReadLogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushReadLogRequest* internal_default_instance() {
    return reinterpret_cast<const PushReadLogRequest*>(
               &_PushReadLogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PushReadLogRequest& a, PushReadLogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PushReadLogRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushReadLogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PushReadLogRequest* New() const final {
    return new PushReadLogRequest();
  }

  PushReadLogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PushReadLogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushReadLogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PushReadLogRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushReadLogRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tapdata.PushReadLogRequest";
  }
  protected:
  explicit PushReadLogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLogResponseFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .tapdata.ReadLogResponse logResponse = 2;
  bool has_logresponse() const;
  private:
  bool _internal_has_logresponse() const;
  public:
  void clear_logresponse();
  const ::tapdata::ReadLogResponse& logresponse() const;
  PROTOBUF_MUST_USE_RESULT ::tapdata::ReadLogResponse* release_logresponse();
  ::tapdata::ReadLogResponse* mutable_logresponse();
  void set_allocated_logresponse(::tapdata::ReadLogResponse* logresponse);
  private:
  const ::tapdata::ReadLogResponse& _internal_logresponse() const;
  ::tapdata::ReadLogResponse* _internal_mutable_logresponse();
  public:
  void unsafe_arena_set_allocated_logresponse(
      ::tapdata::ReadLogResponse* logresponse);
  ::tapdata::ReadLogResponse* unsafe_arena_release_logresponse();

  // @@protoc_insertion_point(class_scope:tapdata.PushReadLogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::tapdata::ReadLogResponse* logresponse_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DB2PlugInDataSource_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MessageHeader

// int32 ProtocolVersion = 1;
inline void MessageHeader::clear_protocolversion() {
  protocolversion_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageHeader::_internal_protocolversion() const {
  return protocolversion_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageHeader::protocolversion() const {
  // @@protoc_insertion_point(field_get:tapdata.MessageHeader.ProtocolVersion)
  return _internal_protocolversion();
}
inline void MessageHeader::_internal_set_protocolversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  protocolversion_ = value;
}
inline void MessageHeader::set_protocolversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_protocolversion(value);
  // @@protoc_insertion_point(field_set:tapdata.MessageHeader.ProtocolVersion)
}

// -------------------------------------------------------------------

// PingRequest

// .tapdata.MessageHeader header = 1;
inline bool PingRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool PingRequest::has_header() const {
  return _internal_has_header();
}
inline void PingRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::tapdata::MessageHeader& PingRequest::_internal_header() const {
  const ::tapdata::MessageHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::MessageHeader&>(
      ::tapdata::_MessageHeader_default_instance_);
}
inline const ::tapdata::MessageHeader& PingRequest::header() const {
  // @@protoc_insertion_point(field_get:tapdata.PingRequest.header)
  return _internal_header();
}
inline void PingRequest::unsafe_arena_set_allocated_header(
    ::tapdata::MessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.PingRequest.header)
}
inline ::tapdata::MessageHeader* PingRequest::release_header() {
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::MessageHeader* PingRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tapdata.PingRequest.header)
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::tapdata::MessageHeader* PingRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::MessageHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::tapdata::MessageHeader* PingRequest::mutable_header() {
  ::tapdata::MessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tapdata.PingRequest.header)
  return _msg;
}
inline void PingRequest::set_allocated_header(::tapdata::MessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::MessageHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tapdata.PingRequest.header)
}

// int32 code = 2;
inline void PingRequest::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PingRequest::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PingRequest::code() const {
  // @@protoc_insertion_point(field_get:tapdata.PingRequest.code)
  return _internal_code();
}
inline void PingRequest::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void PingRequest::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tapdata.PingRequest.code)
}

// -------------------------------------------------------------------

// PingResponse

// .tapdata.MessageHeader header = 1;
inline bool PingResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool PingResponse::has_header() const {
  return _internal_has_header();
}
inline void PingResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::tapdata::MessageHeader& PingResponse::_internal_header() const {
  const ::tapdata::MessageHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::MessageHeader&>(
      ::tapdata::_MessageHeader_default_instance_);
}
inline const ::tapdata::MessageHeader& PingResponse::header() const {
  // @@protoc_insertion_point(field_get:tapdata.PingResponse.header)
  return _internal_header();
}
inline void PingResponse::unsafe_arena_set_allocated_header(
    ::tapdata::MessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.PingResponse.header)
}
inline ::tapdata::MessageHeader* PingResponse::release_header() {
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::MessageHeader* PingResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tapdata.PingResponse.header)
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::tapdata::MessageHeader* PingResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::MessageHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::tapdata::MessageHeader* PingResponse::mutable_header() {
  ::tapdata::MessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tapdata.PingResponse.header)
  return _msg;
}
inline void PingResponse::set_allocated_header(::tapdata::MessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::MessageHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tapdata.PingResponse.header)
}

// int32 status = 2;
inline void PingResponse::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PingResponse::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PingResponse::status() const {
  // @@protoc_insertion_point(field_get:tapdata.PingResponse.status)
  return _internal_status();
}
inline void PingResponse::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void PingResponse::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:tapdata.PingResponse.status)
}

// string msg = 3;
inline void PingResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& PingResponse::msg() const {
  // @@protoc_insertion_point(field_get:tapdata.PingResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PingResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.PingResponse.msg)
}
inline std::string* PingResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:tapdata.PingResponse.msg)
  return _s;
}
inline const std::string& PingResponse::_internal_msg() const {
  return msg_.Get();
}
inline void PingResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PingResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PingResponse::release_msg() {
  // @@protoc_insertion_point(field_release:tapdata.PingResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PingResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.PingResponse.msg)
}

// -------------------------------------------------------------------

// ServerInfoResponse

// .tapdata.MessageHeader header = 1;
inline bool ServerInfoResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ServerInfoResponse::has_header() const {
  return _internal_has_header();
}
inline void ServerInfoResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::tapdata::MessageHeader& ServerInfoResponse::_internal_header() const {
  const ::tapdata::MessageHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::MessageHeader&>(
      ::tapdata::_MessageHeader_default_instance_);
}
inline const ::tapdata::MessageHeader& ServerInfoResponse::header() const {
  // @@protoc_insertion_point(field_get:tapdata.ServerInfoResponse.header)
  return _internal_header();
}
inline void ServerInfoResponse::unsafe_arena_set_allocated_header(
    ::tapdata::MessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.ServerInfoResponse.header)
}
inline ::tapdata::MessageHeader* ServerInfoResponse::release_header() {
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::MessageHeader* ServerInfoResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tapdata.ServerInfoResponse.header)
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::tapdata::MessageHeader* ServerInfoResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::MessageHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::tapdata::MessageHeader* ServerInfoResponse::mutable_header() {
  ::tapdata::MessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tapdata.ServerInfoResponse.header)
  return _msg;
}
inline void ServerInfoResponse::set_allocated_header(::tapdata::MessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::MessageHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tapdata.ServerInfoResponse.header)
}

// int32 serverVersion = 2;
inline void ServerInfoResponse::clear_serverversion() {
  serverversion_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerInfoResponse::_internal_serverversion() const {
  return serverversion_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerInfoResponse::serverversion() const {
  // @@protoc_insertion_point(field_get:tapdata.ServerInfoResponse.serverVersion)
  return _internal_serverversion();
}
inline void ServerInfoResponse::_internal_set_serverversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  serverversion_ = value;
}
inline void ServerInfoResponse::set_serverversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_serverversion(value);
  // @@protoc_insertion_point(field_set:tapdata.ServerInfoResponse.serverVersion)
}

// string info = 3;
inline void ServerInfoResponse::clear_info() {
  info_.ClearToEmpty();
}
inline const std::string& ServerInfoResponse::info() const {
  // @@protoc_insertion_point(field_get:tapdata.ServerInfoResponse.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfoResponse::set_info(ArgT0&& arg0, ArgT... args) {
 
 info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ServerInfoResponse.info)
}
inline std::string* ServerInfoResponse::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tapdata.ServerInfoResponse.info)
  return _s;
}
inline const std::string& ServerInfoResponse::_internal_info() const {
  return info_.Get();
}
inline void ServerInfoResponse::_internal_set_info(const std::string& value) {
  
  info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerInfoResponse::_internal_mutable_info() {
  
  return info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerInfoResponse::release_info() {
  // @@protoc_insertion_point(field_release:tapdata.ServerInfoResponse.info)
  return info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServerInfoResponse::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ServerInfoResponse.info)
}

// .tapdata.DB2Veresion supportVersion = 4;
inline void ServerInfoResponse::clear_supportversion() {
  supportversion_ = 0;
}
inline ::tapdata::DB2Veresion ServerInfoResponse::_internal_supportversion() const {
  return static_cast< ::tapdata::DB2Veresion >(supportversion_);
}
inline ::tapdata::DB2Veresion ServerInfoResponse::supportversion() const {
  // @@protoc_insertion_point(field_get:tapdata.ServerInfoResponse.supportVersion)
  return _internal_supportversion();
}
inline void ServerInfoResponse::_internal_set_supportversion(::tapdata::DB2Veresion value) {
  
  supportversion_ = value;
}
inline void ServerInfoResponse::set_supportversion(::tapdata::DB2Veresion value) {
  _internal_set_supportversion(value);
  // @@protoc_insertion_point(field_set:tapdata.ServerInfoResponse.supportVersion)
}

// repeated int32 supportProtocolVersion = 5;
inline int ServerInfoResponse::_internal_supportprotocolversion_size() const {
  return supportprotocolversion_.size();
}
inline int ServerInfoResponse::supportprotocolversion_size() const {
  return _internal_supportprotocolversion_size();
}
inline void ServerInfoResponse::clear_supportprotocolversion() {
  supportprotocolversion_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerInfoResponse::_internal_supportprotocolversion(int index) const {
  return supportprotocolversion_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerInfoResponse::supportprotocolversion(int index) const {
  // @@protoc_insertion_point(field_get:tapdata.ServerInfoResponse.supportProtocolVersion)
  return _internal_supportprotocolversion(index);
}
inline void ServerInfoResponse::set_supportprotocolversion(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  supportprotocolversion_.Set(index, value);
  // @@protoc_insertion_point(field_set:tapdata.ServerInfoResponse.supportProtocolVersion)
}
inline void ServerInfoResponse::_internal_add_supportprotocolversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  supportprotocolversion_.Add(value);
}
inline void ServerInfoResponse::add_supportprotocolversion(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_supportprotocolversion(value);
  // @@protoc_insertion_point(field_add:tapdata.ServerInfoResponse.supportProtocolVersion)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ServerInfoResponse::_internal_supportprotocolversion() const {
  return supportprotocolversion_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ServerInfoResponse::supportprotocolversion() const {
  // @@protoc_insertion_point(field_list:tapdata.ServerInfoResponse.supportProtocolVersion)
  return _internal_supportprotocolversion();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ServerInfoResponse::_internal_mutable_supportprotocolversion() {
  return &supportprotocolversion_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ServerInfoResponse::mutable_supportprotocolversion() {
  // @@protoc_insertion_point(field_mutable_list:tapdata.ServerInfoResponse.supportProtocolVersion)
  return _internal_mutable_supportprotocolversion();
}

// repeated .tapdata.WriterType supportWriterType = 6;
inline int ServerInfoResponse::_internal_supportwritertype_size() const {
  return supportwritertype_.size();
}
inline int ServerInfoResponse::supportwritertype_size() const {
  return _internal_supportwritertype_size();
}
inline void ServerInfoResponse::clear_supportwritertype() {
  supportwritertype_.Clear();
}
inline ::tapdata::WriterType ServerInfoResponse::_internal_supportwritertype(int index) const {
  return static_cast< ::tapdata::WriterType >(supportwritertype_.Get(index));
}
inline ::tapdata::WriterType ServerInfoResponse::supportwritertype(int index) const {
  // @@protoc_insertion_point(field_get:tapdata.ServerInfoResponse.supportWriterType)
  return _internal_supportwritertype(index);
}
inline void ServerInfoResponse::set_supportwritertype(int index, ::tapdata::WriterType value) {
  supportwritertype_.Set(index, value);
  // @@protoc_insertion_point(field_set:tapdata.ServerInfoResponse.supportWriterType)
}
inline void ServerInfoResponse::_internal_add_supportwritertype(::tapdata::WriterType value) {
  supportwritertype_.Add(value);
}
inline void ServerInfoResponse::add_supportwritertype(::tapdata::WriterType value) {
  _internal_add_supportwritertype(value);
  // @@protoc_insertion_point(field_add:tapdata.ServerInfoResponse.supportWriterType)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ServerInfoResponse::supportwritertype() const {
  // @@protoc_insertion_point(field_list:tapdata.ServerInfoResponse.supportWriterType)
  return supportwritertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ServerInfoResponse::_internal_mutable_supportwritertype() {
  return &supportwritertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ServerInfoResponse::mutable_supportwritertype() {
  // @@protoc_insertion_point(field_mutable_list:tapdata.ServerInfoResponse.supportWriterType)
  return _internal_mutable_supportwritertype();
}

// -------------------------------------------------------------------

// ReaderSource

// .tapdata.DB2Veresion databaseVersion = 1;
inline void ReaderSource::clear_databaseversion() {
  databaseversion_ = 0;
}
inline ::tapdata::DB2Veresion ReaderSource::_internal_databaseversion() const {
  return static_cast< ::tapdata::DB2Veresion >(databaseversion_);
}
inline ::tapdata::DB2Veresion ReaderSource::databaseversion() const {
  // @@protoc_insertion_point(field_get:tapdata.ReaderSource.databaseVersion)
  return _internal_databaseversion();
}
inline void ReaderSource::_internal_set_databaseversion(::tapdata::DB2Veresion value) {
  
  databaseversion_ = value;
}
inline void ReaderSource::set_databaseversion(::tapdata::DB2Veresion value) {
  _internal_set_databaseversion(value);
  // @@protoc_insertion_point(field_set:tapdata.ReaderSource.databaseVersion)
}

// string databaseName = 2;
inline void ReaderSource::clear_databasename() {
  databasename_.ClearToEmpty();
}
inline const std::string& ReaderSource::databasename() const {
  // @@protoc_insertion_point(field_get:tapdata.ReaderSource.databaseName)
  return _internal_databasename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReaderSource::set_databasename(ArgT0&& arg0, ArgT... args) {
 
 databasename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReaderSource.databaseName)
}
inline std::string* ReaderSource::mutable_databasename() {
  std::string* _s = _internal_mutable_databasename();
  // @@protoc_insertion_point(field_mutable:tapdata.ReaderSource.databaseName)
  return _s;
}
inline const std::string& ReaderSource::_internal_databasename() const {
  return databasename_.Get();
}
inline void ReaderSource::_internal_set_databasename(const std::string& value) {
  
  databasename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReaderSource::_internal_mutable_databasename() {
  
  return databasename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReaderSource::release_databasename() {
  // @@protoc_insertion_point(field_release:tapdata.ReaderSource.databaseName)
  return databasename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReaderSource::set_allocated_databasename(std::string* databasename) {
  if (databasename != nullptr) {
    
  } else {
    
  }
  databasename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), databasename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReaderSource.databaseName)
}

// string databaseUsername = 3;
inline void ReaderSource::clear_databaseusername() {
  databaseusername_.ClearToEmpty();
}
inline const std::string& ReaderSource::databaseusername() const {
  // @@protoc_insertion_point(field_get:tapdata.ReaderSource.databaseUsername)
  return _internal_databaseusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReaderSource::set_databaseusername(ArgT0&& arg0, ArgT... args) {
 
 databaseusername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReaderSource.databaseUsername)
}
inline std::string* ReaderSource::mutable_databaseusername() {
  std::string* _s = _internal_mutable_databaseusername();
  // @@protoc_insertion_point(field_mutable:tapdata.ReaderSource.databaseUsername)
  return _s;
}
inline const std::string& ReaderSource::_internal_databaseusername() const {
  return databaseusername_.Get();
}
inline void ReaderSource::_internal_set_databaseusername(const std::string& value) {
  
  databaseusername_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReaderSource::_internal_mutable_databaseusername() {
  
  return databaseusername_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReaderSource::release_databaseusername() {
  // @@protoc_insertion_point(field_release:tapdata.ReaderSource.databaseUsername)
  return databaseusername_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReaderSource::set_allocated_databaseusername(std::string* databaseusername) {
  if (databaseusername != nullptr) {
    
  } else {
    
  }
  databaseusername_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), databaseusername,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReaderSource.databaseUsername)
}

// string databasePassword = 4;
inline void ReaderSource::clear_databasepassword() {
  databasepassword_.ClearToEmpty();
}
inline const std::string& ReaderSource::databasepassword() const {
  // @@protoc_insertion_point(field_get:tapdata.ReaderSource.databasePassword)
  return _internal_databasepassword();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReaderSource::set_databasepassword(ArgT0&& arg0, ArgT... args) {
 
 databasepassword_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReaderSource.databasePassword)
}
inline std::string* ReaderSource::mutable_databasepassword() {
  std::string* _s = _internal_mutable_databasepassword();
  // @@protoc_insertion_point(field_mutable:tapdata.ReaderSource.databasePassword)
  return _s;
}
inline const std::string& ReaderSource::_internal_databasepassword() const {
  return databasepassword_.Get();
}
inline void ReaderSource::_internal_set_databasepassword(const std::string& value) {
  
  databasepassword_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReaderSource::_internal_mutable_databasepassword() {
  
  return databasepassword_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReaderSource::release_databasepassword() {
  // @@protoc_insertion_point(field_release:tapdata.ReaderSource.databasePassword)
  return databasepassword_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReaderSource::set_allocated_databasepassword(std::string* databasepassword) {
  if (databasepassword != nullptr) {
    
  } else {
    
  }
  databasepassword_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), databasepassword,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReaderSource.databasePassword)
}

// string databaseHostname = 5;
inline void ReaderSource::clear_databasehostname() {
  databasehostname_.ClearToEmpty();
}
inline const std::string& ReaderSource::databasehostname() const {
  // @@protoc_insertion_point(field_get:tapdata.ReaderSource.databaseHostname)
  return _internal_databasehostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReaderSource::set_databasehostname(ArgT0&& arg0, ArgT... args) {
 
 databasehostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReaderSource.databaseHostname)
}
inline std::string* ReaderSource::mutable_databasehostname() {
  std::string* _s = _internal_mutable_databasehostname();
  // @@protoc_insertion_point(field_mutable:tapdata.ReaderSource.databaseHostname)
  return _s;
}
inline const std::string& ReaderSource::_internal_databasehostname() const {
  return databasehostname_.Get();
}
inline void ReaderSource::_internal_set_databasehostname(const std::string& value) {
  
  databasehostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReaderSource::_internal_mutable_databasehostname() {
  
  return databasehostname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReaderSource::release_databasehostname() {
  // @@protoc_insertion_point(field_release:tapdata.ReaderSource.databaseHostname)
  return databasehostname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReaderSource::set_allocated_databasehostname(std::string* databasehostname) {
  if (databasehostname != nullptr) {
    
  } else {
    
  }
  databasehostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), databasehostname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReaderSource.databaseHostname)
}

// string databaseServiceName = 6;
inline void ReaderSource::clear_databaseservicename() {
  databaseservicename_.ClearToEmpty();
}
inline const std::string& ReaderSource::databaseservicename() const {
  // @@protoc_insertion_point(field_get:tapdata.ReaderSource.databaseServiceName)
  return _internal_databaseservicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReaderSource::set_databaseservicename(ArgT0&& arg0, ArgT... args) {
 
 databaseservicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReaderSource.databaseServiceName)
}
inline std::string* ReaderSource::mutable_databaseservicename() {
  std::string* _s = _internal_mutable_databaseservicename();
  // @@protoc_insertion_point(field_mutable:tapdata.ReaderSource.databaseServiceName)
  return _s;
}
inline const std::string& ReaderSource::_internal_databaseservicename() const {
  return databaseservicename_.Get();
}
inline void ReaderSource::_internal_set_databaseservicename(const std::string& value) {
  
  databaseservicename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReaderSource::_internal_mutable_databaseservicename() {
  
  return databaseservicename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReaderSource::release_databaseservicename() {
  // @@protoc_insertion_point(field_release:tapdata.ReaderSource.databaseServiceName)
  return databaseservicename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReaderSource::set_allocated_databaseservicename(std::string* databaseservicename) {
  if (databaseservicename != nullptr) {
    
  } else {
    
  }
  databaseservicename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), databaseservicename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReaderSource.databaseServiceName)
}

// -------------------------------------------------------------------

// WriterTarget

// .tapdata.WriterType type = 1;
inline void WriterTarget::clear_type() {
  type_ = 0;
}
inline ::tapdata::WriterType WriterTarget::_internal_type() const {
  return static_cast< ::tapdata::WriterType >(type_);
}
inline ::tapdata::WriterType WriterTarget::type() const {
  // @@protoc_insertion_point(field_get:tapdata.WriterTarget.type)
  return _internal_type();
}
inline void WriterTarget::_internal_set_type(::tapdata::WriterType value) {
  
  type_ = value;
}
inline void WriterTarget::set_type(::tapdata::WriterType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tapdata.WriterTarget.type)
}

// string kafkaWriterTopic = 2;
inline void WriterTarget::clear_kafkawritertopic() {
  kafkawritertopic_.ClearToEmpty();
}
inline const std::string& WriterTarget::kafkawritertopic() const {
  // @@protoc_insertion_point(field_get:tapdata.WriterTarget.kafkaWriterTopic)
  return _internal_kafkawritertopic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriterTarget::set_kafkawritertopic(ArgT0&& arg0, ArgT... args) {
 
 kafkawritertopic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.WriterTarget.kafkaWriterTopic)
}
inline std::string* WriterTarget::mutable_kafkawritertopic() {
  std::string* _s = _internal_mutable_kafkawritertopic();
  // @@protoc_insertion_point(field_mutable:tapdata.WriterTarget.kafkaWriterTopic)
  return _s;
}
inline const std::string& WriterTarget::_internal_kafkawritertopic() const {
  return kafkawritertopic_.Get();
}
inline void WriterTarget::_internal_set_kafkawritertopic(const std::string& value) {
  
  kafkawritertopic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WriterTarget::_internal_mutable_kafkawritertopic() {
  
  return kafkawritertopic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WriterTarget::release_kafkawritertopic() {
  // @@protoc_insertion_point(field_release:tapdata.WriterTarget.kafkaWriterTopic)
  return kafkawritertopic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WriterTarget::set_allocated_kafkawritertopic(std::string* kafkawritertopic) {
  if (kafkawritertopic != nullptr) {
    
  } else {
    
  }
  kafkawritertopic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kafkawritertopic,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.WriterTarget.kafkaWriterTopic)
}

// string kafkaWriterBrokers = 3;
inline void WriterTarget::clear_kafkawriterbrokers() {
  kafkawriterbrokers_.ClearToEmpty();
}
inline const std::string& WriterTarget::kafkawriterbrokers() const {
  // @@protoc_insertion_point(field_get:tapdata.WriterTarget.kafkaWriterBrokers)
  return _internal_kafkawriterbrokers();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriterTarget::set_kafkawriterbrokers(ArgT0&& arg0, ArgT... args) {
 
 kafkawriterbrokers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.WriterTarget.kafkaWriterBrokers)
}
inline std::string* WriterTarget::mutable_kafkawriterbrokers() {
  std::string* _s = _internal_mutable_kafkawriterbrokers();
  // @@protoc_insertion_point(field_mutable:tapdata.WriterTarget.kafkaWriterBrokers)
  return _s;
}
inline const std::string& WriterTarget::_internal_kafkawriterbrokers() const {
  return kafkawriterbrokers_.Get();
}
inline void WriterTarget::_internal_set_kafkawriterbrokers(const std::string& value) {
  
  kafkawriterbrokers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WriterTarget::_internal_mutable_kafkawriterbrokers() {
  
  return kafkawriterbrokers_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WriterTarget::release_kafkawriterbrokers() {
  // @@protoc_insertion_point(field_release:tapdata.WriterTarget.kafkaWriterBrokers)
  return kafkawriterbrokers_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WriterTarget::set_allocated_kafkawriterbrokers(std::string* kafkawriterbrokers) {
  if (kafkawriterbrokers != nullptr) {
    
  } else {
    
  }
  kafkawriterbrokers_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kafkawriterbrokers,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.WriterTarget.kafkaWriterBrokers)
}

// -------------------------------------------------------------------

// SourceTable

// int32 tableId = 1;
inline void SourceTable::clear_tableid() {
  tableid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SourceTable::_internal_tableid() const {
  return tableid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SourceTable::tableid() const {
  // @@protoc_insertion_point(field_get:tapdata.SourceTable.tableId)
  return _internal_tableid();
}
inline void SourceTable::_internal_set_tableid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tableid_ = value;
}
inline void SourceTable::set_tableid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tableid(value);
  // @@protoc_insertion_point(field_set:tapdata.SourceTable.tableId)
}

// int32 tableSpaceId = 2;
inline void SourceTable::clear_tablespaceid() {
  tablespaceid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SourceTable::_internal_tablespaceid() const {
  return tablespaceid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SourceTable::tablespaceid() const {
  // @@protoc_insertion_point(field_get:tapdata.SourceTable.tableSpaceId)
  return _internal_tablespaceid();
}
inline void SourceTable::_internal_set_tablespaceid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tablespaceid_ = value;
}
inline void SourceTable::set_tablespaceid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tablespaceid(value);
  // @@protoc_insertion_point(field_set:tapdata.SourceTable.tableSpaceId)
}

// -------------------------------------------------------------------

// ReadLogRequest

// .tapdata.MessageHeader header = 1;
inline bool ReadLogRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ReadLogRequest::has_header() const {
  return _internal_has_header();
}
inline void ReadLogRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::tapdata::MessageHeader& ReadLogRequest::_internal_header() const {
  const ::tapdata::MessageHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::MessageHeader&>(
      ::tapdata::_MessageHeader_default_instance_);
}
inline const ::tapdata::MessageHeader& ReadLogRequest::header() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogRequest.header)
  return _internal_header();
}
inline void ReadLogRequest::unsafe_arena_set_allocated_header(
    ::tapdata::MessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.ReadLogRequest.header)
}
inline ::tapdata::MessageHeader* ReadLogRequest::release_header() {
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::MessageHeader* ReadLogRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogRequest.header)
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::tapdata::MessageHeader* ReadLogRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::MessageHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::tapdata::MessageHeader* ReadLogRequest::mutable_header() {
  ::tapdata::MessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogRequest.header)
  return _msg;
}
inline void ReadLogRequest::set_allocated_header(::tapdata::MessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::MessageHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogRequest.header)
}

// bool bigEndian = 2;
inline void ReadLogRequest::clear_bigendian() {
  bigendian_ = false;
}
inline bool ReadLogRequest::_internal_bigendian() const {
  return bigendian_;
}
inline bool ReadLogRequest::bigendian() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogRequest.bigEndian)
  return _internal_bigendian();
}
inline void ReadLogRequest::_internal_set_bigendian(bool value) {
  
  bigendian_ = value;
}
inline void ReadLogRequest::set_bigendian(bool value) {
  _internal_set_bigendian(value);
  // @@protoc_insertion_point(field_set:tapdata.ReadLogRequest.bigEndian)
}

// string id = 3;
inline void ReadLogRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ReadLogRequest::id() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogRequest.id)
}
inline std::string* ReadLogRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogRequest.id)
  return _s;
}
inline const std::string& ReadLogRequest::_internal_id() const {
  return id_.Get();
}
inline void ReadLogRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogRequest::release_id() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogRequest.id)
}

// string scn = 4;
inline void ReadLogRequest::clear_scn() {
  scn_.ClearToEmpty();
}
inline const std::string& ReadLogRequest::scn() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogRequest.scn)
  return _internal_scn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogRequest::set_scn(ArgT0&& arg0, ArgT... args) {
 
 scn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogRequest.scn)
}
inline std::string* ReadLogRequest::mutable_scn() {
  std::string* _s = _internal_mutable_scn();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogRequest.scn)
  return _s;
}
inline const std::string& ReadLogRequest::_internal_scn() const {
  return scn_.Get();
}
inline void ReadLogRequest::_internal_set_scn(const std::string& value) {
  
  scn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogRequest::_internal_mutable_scn() {
  
  return scn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogRequest::release_scn() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogRequest.scn)
  return scn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogRequest::set_allocated_scn(std::string* scn) {
  if (scn != nullptr) {
    
  } else {
    
  }
  scn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scn,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogRequest.scn)
}

// int64 stime = 5;
inline void ReadLogRequest::clear_stime() {
  stime_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReadLogRequest::_internal_stime() const {
  return stime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReadLogRequest::stime() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogRequest.stime)
  return _internal_stime();
}
inline void ReadLogRequest::_internal_set_stime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  stime_ = value;
}
inline void ReadLogRequest::set_stime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_stime(value);
  // @@protoc_insertion_point(field_set:tapdata.ReadLogRequest.stime)
}

// repeated .tapdata.SourceTable tables = 6;
inline int ReadLogRequest::_internal_tables_size() const {
  return tables_.size();
}
inline int ReadLogRequest::tables_size() const {
  return _internal_tables_size();
}
inline void ReadLogRequest::clear_tables() {
  tables_.Clear();
}
inline ::tapdata::SourceTable* ReadLogRequest::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogRequest.tables)
  return tables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::SourceTable >*
ReadLogRequest::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:tapdata.ReadLogRequest.tables)
  return &tables_;
}
inline const ::tapdata::SourceTable& ReadLogRequest::_internal_tables(int index) const {
  return tables_.Get(index);
}
inline const ::tapdata::SourceTable& ReadLogRequest::tables(int index) const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogRequest.tables)
  return _internal_tables(index);
}
inline ::tapdata::SourceTable* ReadLogRequest::_internal_add_tables() {
  return tables_.Add();
}
inline ::tapdata::SourceTable* ReadLogRequest::add_tables() {
  ::tapdata::SourceTable* _add = _internal_add_tables();
  // @@protoc_insertion_point(field_add:tapdata.ReadLogRequest.tables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::SourceTable >&
ReadLogRequest::tables() const {
  // @@protoc_insertion_point(field_list:tapdata.ReadLogRequest.tables)
  return tables_;
}

// .tapdata.ReaderSource source = 7;
inline bool ReadLogRequest::_internal_has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline bool ReadLogRequest::has_source() const {
  return _internal_has_source();
}
inline void ReadLogRequest::clear_source() {
  if (GetArenaForAllocation() == nullptr && source_ != nullptr) {
    delete source_;
  }
  source_ = nullptr;
}
inline const ::tapdata::ReaderSource& ReadLogRequest::_internal_source() const {
  const ::tapdata::ReaderSource* p = source_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::ReaderSource&>(
      ::tapdata::_ReaderSource_default_instance_);
}
inline const ::tapdata::ReaderSource& ReadLogRequest::source() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogRequest.source)
  return _internal_source();
}
inline void ReadLogRequest::unsafe_arena_set_allocated_source(
    ::tapdata::ReaderSource* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.ReadLogRequest.source)
}
inline ::tapdata::ReaderSource* ReadLogRequest::release_source() {
  
  ::tapdata::ReaderSource* temp = source_;
  source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::ReaderSource* ReadLogRequest::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogRequest.source)
  
  ::tapdata::ReaderSource* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::tapdata::ReaderSource* ReadLogRequest::_internal_mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::ReaderSource>(GetArenaForAllocation());
    source_ = p;
  }
  return source_;
}
inline ::tapdata::ReaderSource* ReadLogRequest::mutable_source() {
  ::tapdata::ReaderSource* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogRequest.source)
  return _msg;
}
inline void ReadLogRequest::set_allocated_source(::tapdata::ReaderSource* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::ReaderSource>::GetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogRequest.source)
}

// .tapdata.WriterTarget target = 8;
inline bool ReadLogRequest::_internal_has_target() const {
  return this != internal_default_instance() && target_ != nullptr;
}
inline bool ReadLogRequest::has_target() const {
  return _internal_has_target();
}
inline void ReadLogRequest::clear_target() {
  if (GetArenaForAllocation() == nullptr && target_ != nullptr) {
    delete target_;
  }
  target_ = nullptr;
}
inline const ::tapdata::WriterTarget& ReadLogRequest::_internal_target() const {
  const ::tapdata::WriterTarget* p = target_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::WriterTarget&>(
      ::tapdata::_WriterTarget_default_instance_);
}
inline const ::tapdata::WriterTarget& ReadLogRequest::target() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogRequest.target)
  return _internal_target();
}
inline void ReadLogRequest::unsafe_arena_set_allocated_target(
    ::tapdata::WriterTarget* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_);
  }
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.ReadLogRequest.target)
}
inline ::tapdata::WriterTarget* ReadLogRequest::release_target() {
  
  ::tapdata::WriterTarget* temp = target_;
  target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::WriterTarget* ReadLogRequest::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogRequest.target)
  
  ::tapdata::WriterTarget* temp = target_;
  target_ = nullptr;
  return temp;
}
inline ::tapdata::WriterTarget* ReadLogRequest::_internal_mutable_target() {
  
  if (target_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::WriterTarget>(GetArenaForAllocation());
    target_ = p;
  }
  return target_;
}
inline ::tapdata::WriterTarget* ReadLogRequest::mutable_target() {
  ::tapdata::WriterTarget* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogRequest.target)
  return _msg;
}
inline void ReadLogRequest::set_allocated_target(::tapdata::WriterTarget* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::WriterTarget>::GetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogRequest.target)
}

// -------------------------------------------------------------------

// TaskHandleRequest

// .tapdata.MessageHeader header = 1;
inline bool TaskHandleRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool TaskHandleRequest::has_header() const {
  return _internal_has_header();
}
inline void TaskHandleRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::tapdata::MessageHeader& TaskHandleRequest::_internal_header() const {
  const ::tapdata::MessageHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::MessageHeader&>(
      ::tapdata::_MessageHeader_default_instance_);
}
inline const ::tapdata::MessageHeader& TaskHandleRequest::header() const {
  // @@protoc_insertion_point(field_get:tapdata.TaskHandleRequest.header)
  return _internal_header();
}
inline void TaskHandleRequest::unsafe_arena_set_allocated_header(
    ::tapdata::MessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.TaskHandleRequest.header)
}
inline ::tapdata::MessageHeader* TaskHandleRequest::release_header() {
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::MessageHeader* TaskHandleRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tapdata.TaskHandleRequest.header)
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::tapdata::MessageHeader* TaskHandleRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::MessageHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::tapdata::MessageHeader* TaskHandleRequest::mutable_header() {
  ::tapdata::MessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tapdata.TaskHandleRequest.header)
  return _msg;
}
inline void TaskHandleRequest::set_allocated_header(::tapdata::MessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::MessageHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tapdata.TaskHandleRequest.header)
}

// string id = 2;
inline void TaskHandleRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TaskHandleRequest::id() const {
  // @@protoc_insertion_point(field_get:tapdata.TaskHandleRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskHandleRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.TaskHandleRequest.id)
}
inline std::string* TaskHandleRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:tapdata.TaskHandleRequest.id)
  return _s;
}
inline const std::string& TaskHandleRequest::_internal_id() const {
  return id_.Get();
}
inline void TaskHandleRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskHandleRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskHandleRequest::release_id() {
  // @@protoc_insertion_point(field_release:tapdata.TaskHandleRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskHandleRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.TaskHandleRequest.id)
}

// -------------------------------------------------------------------

// ControlResponse

// .tapdata.MessageHeader header = 1;
inline bool ControlResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ControlResponse::has_header() const {
  return _internal_has_header();
}
inline void ControlResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::tapdata::MessageHeader& ControlResponse::_internal_header() const {
  const ::tapdata::MessageHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::MessageHeader&>(
      ::tapdata::_MessageHeader_default_instance_);
}
inline const ::tapdata::MessageHeader& ControlResponse::header() const {
  // @@protoc_insertion_point(field_get:tapdata.ControlResponse.header)
  return _internal_header();
}
inline void ControlResponse::unsafe_arena_set_allocated_header(
    ::tapdata::MessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.ControlResponse.header)
}
inline ::tapdata::MessageHeader* ControlResponse::release_header() {
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::MessageHeader* ControlResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tapdata.ControlResponse.header)
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::tapdata::MessageHeader* ControlResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::MessageHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::tapdata::MessageHeader* ControlResponse::mutable_header() {
  ::tapdata::MessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tapdata.ControlResponse.header)
  return _msg;
}
inline void ControlResponse::set_allocated_header(::tapdata::MessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::MessageHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tapdata.ControlResponse.header)
}

// .tapdata.ResponseCode code = 2;
inline void ControlResponse::clear_code() {
  code_ = 0;
}
inline ::tapdata::ResponseCode ControlResponse::_internal_code() const {
  return static_cast< ::tapdata::ResponseCode >(code_);
}
inline ::tapdata::ResponseCode ControlResponse::code() const {
  // @@protoc_insertion_point(field_get:tapdata.ControlResponse.code)
  return _internal_code();
}
inline void ControlResponse::_internal_set_code(::tapdata::ResponseCode value) {
  
  code_ = value;
}
inline void ControlResponse::set_code(::tapdata::ResponseCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tapdata.ControlResponse.code)
}

// string msg = 3;
inline void ControlResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& ControlResponse::msg() const {
  // @@protoc_insertion_point(field_get:tapdata.ControlResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ControlResponse.msg)
}
inline std::string* ControlResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:tapdata.ControlResponse.msg)
  return _s;
}
inline const std::string& ControlResponse::_internal_msg() const {
  return msg_.Get();
}
inline void ControlResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControlResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControlResponse::release_msg() {
  // @@protoc_insertion_point(field_release:tapdata.ControlResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControlResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ControlResponse.msg)
}

// -------------------------------------------------------------------

// ReadLogTaskState

// string id = 1;
inline void ReadLogTaskState::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ReadLogTaskState::id() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogTaskState.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogTaskState::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogTaskState.id)
}
inline std::string* ReadLogTaskState::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogTaskState.id)
  return _s;
}
inline const std::string& ReadLogTaskState::_internal_id() const {
  return id_.Get();
}
inline void ReadLogTaskState::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogTaskState::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogTaskState::release_id() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogTaskState.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogTaskState::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogTaskState.id)
}

// .tapdata.TaskState state = 2;
inline void ReadLogTaskState::clear_state() {
  state_ = 0;
}
inline ::tapdata::TaskState ReadLogTaskState::_internal_state() const {
  return static_cast< ::tapdata::TaskState >(state_);
}
inline ::tapdata::TaskState ReadLogTaskState::state() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogTaskState.state)
  return _internal_state();
}
inline void ReadLogTaskState::_internal_set_state(::tapdata::TaskState value) {
  
  state_ = value;
}
inline void ReadLogTaskState::set_state(::tapdata::TaskState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:tapdata.ReadLogTaskState.state)
}

// -------------------------------------------------------------------

// ListReadLogTaskStatesRequest

// .tapdata.MessageHeader header = 1;
inline bool ListReadLogTaskStatesRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListReadLogTaskStatesRequest::has_header() const {
  return _internal_has_header();
}
inline void ListReadLogTaskStatesRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::tapdata::MessageHeader& ListReadLogTaskStatesRequest::_internal_header() const {
  const ::tapdata::MessageHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::MessageHeader&>(
      ::tapdata::_MessageHeader_default_instance_);
}
inline const ::tapdata::MessageHeader& ListReadLogTaskStatesRequest::header() const {
  // @@protoc_insertion_point(field_get:tapdata.ListReadLogTaskStatesRequest.header)
  return _internal_header();
}
inline void ListReadLogTaskStatesRequest::unsafe_arena_set_allocated_header(
    ::tapdata::MessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.ListReadLogTaskStatesRequest.header)
}
inline ::tapdata::MessageHeader* ListReadLogTaskStatesRequest::release_header() {
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::MessageHeader* ListReadLogTaskStatesRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tapdata.ListReadLogTaskStatesRequest.header)
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::tapdata::MessageHeader* ListReadLogTaskStatesRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::MessageHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::tapdata::MessageHeader* ListReadLogTaskStatesRequest::mutable_header() {
  ::tapdata::MessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tapdata.ListReadLogTaskStatesRequest.header)
  return _msg;
}
inline void ListReadLogTaskStatesRequest::set_allocated_header(::tapdata::MessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::MessageHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tapdata.ListReadLogTaskStatesRequest.header)
}

// -------------------------------------------------------------------

// ListReadLogTaskStatesResponse

// .tapdata.MessageHeader header = 1;
inline bool ListReadLogTaskStatesResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListReadLogTaskStatesResponse::has_header() const {
  return _internal_has_header();
}
inline void ListReadLogTaskStatesResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::tapdata::MessageHeader& ListReadLogTaskStatesResponse::_internal_header() const {
  const ::tapdata::MessageHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::MessageHeader&>(
      ::tapdata::_MessageHeader_default_instance_);
}
inline const ::tapdata::MessageHeader& ListReadLogTaskStatesResponse::header() const {
  // @@protoc_insertion_point(field_get:tapdata.ListReadLogTaskStatesResponse.header)
  return _internal_header();
}
inline void ListReadLogTaskStatesResponse::unsafe_arena_set_allocated_header(
    ::tapdata::MessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.ListReadLogTaskStatesResponse.header)
}
inline ::tapdata::MessageHeader* ListReadLogTaskStatesResponse::release_header() {
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::MessageHeader* ListReadLogTaskStatesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tapdata.ListReadLogTaskStatesResponse.header)
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::tapdata::MessageHeader* ListReadLogTaskStatesResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::MessageHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::tapdata::MessageHeader* ListReadLogTaskStatesResponse::mutable_header() {
  ::tapdata::MessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tapdata.ListReadLogTaskStatesResponse.header)
  return _msg;
}
inline void ListReadLogTaskStatesResponse::set_allocated_header(::tapdata::MessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::MessageHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tapdata.ListReadLogTaskStatesResponse.header)
}

// .tapdata.ResponseCode code = 2;
inline void ListReadLogTaskStatesResponse::clear_code() {
  code_ = 0;
}
inline ::tapdata::ResponseCode ListReadLogTaskStatesResponse::_internal_code() const {
  return static_cast< ::tapdata::ResponseCode >(code_);
}
inline ::tapdata::ResponseCode ListReadLogTaskStatesResponse::code() const {
  // @@protoc_insertion_point(field_get:tapdata.ListReadLogTaskStatesResponse.code)
  return _internal_code();
}
inline void ListReadLogTaskStatesResponse::_internal_set_code(::tapdata::ResponseCode value) {
  
  code_ = value;
}
inline void ListReadLogTaskStatesResponse::set_code(::tapdata::ResponseCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tapdata.ListReadLogTaskStatesResponse.code)
}

// repeated .tapdata.ReadLogTaskState taskState = 3;
inline int ListReadLogTaskStatesResponse::_internal_taskstate_size() const {
  return taskstate_.size();
}
inline int ListReadLogTaskStatesResponse::taskstate_size() const {
  return _internal_taskstate_size();
}
inline void ListReadLogTaskStatesResponse::clear_taskstate() {
  taskstate_.Clear();
}
inline ::tapdata::ReadLogTaskState* ListReadLogTaskStatesResponse::mutable_taskstate(int index) {
  // @@protoc_insertion_point(field_mutable:tapdata.ListReadLogTaskStatesResponse.taskState)
  return taskstate_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogTaskState >*
ListReadLogTaskStatesResponse::mutable_taskstate() {
  // @@protoc_insertion_point(field_mutable_list:tapdata.ListReadLogTaskStatesResponse.taskState)
  return &taskstate_;
}
inline const ::tapdata::ReadLogTaskState& ListReadLogTaskStatesResponse::_internal_taskstate(int index) const {
  return taskstate_.Get(index);
}
inline const ::tapdata::ReadLogTaskState& ListReadLogTaskStatesResponse::taskstate(int index) const {
  // @@protoc_insertion_point(field_get:tapdata.ListReadLogTaskStatesResponse.taskState)
  return _internal_taskstate(index);
}
inline ::tapdata::ReadLogTaskState* ListReadLogTaskStatesResponse::_internal_add_taskstate() {
  return taskstate_.Add();
}
inline ::tapdata::ReadLogTaskState* ListReadLogTaskStatesResponse::add_taskstate() {
  ::tapdata::ReadLogTaskState* _add = _internal_add_taskstate();
  // @@protoc_insertion_point(field_add:tapdata.ListReadLogTaskStatesResponse.taskState)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogTaskState >&
ListReadLogTaskStatesResponse::taskstate() const {
  // @@protoc_insertion_point(field_list:tapdata.ListReadLogTaskStatesResponse.taskState)
  return taskstate_;
}

// -------------------------------------------------------------------

// GetReadLogTaskStateResponse

// .tapdata.MessageHeader header = 1;
inline bool GetReadLogTaskStateResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetReadLogTaskStateResponse::has_header() const {
  return _internal_has_header();
}
inline void GetReadLogTaskStateResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::tapdata::MessageHeader& GetReadLogTaskStateResponse::_internal_header() const {
  const ::tapdata::MessageHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::MessageHeader&>(
      ::tapdata::_MessageHeader_default_instance_);
}
inline const ::tapdata::MessageHeader& GetReadLogTaskStateResponse::header() const {
  // @@protoc_insertion_point(field_get:tapdata.GetReadLogTaskStateResponse.header)
  return _internal_header();
}
inline void GetReadLogTaskStateResponse::unsafe_arena_set_allocated_header(
    ::tapdata::MessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.GetReadLogTaskStateResponse.header)
}
inline ::tapdata::MessageHeader* GetReadLogTaskStateResponse::release_header() {
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::MessageHeader* GetReadLogTaskStateResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tapdata.GetReadLogTaskStateResponse.header)
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::tapdata::MessageHeader* GetReadLogTaskStateResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::MessageHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::tapdata::MessageHeader* GetReadLogTaskStateResponse::mutable_header() {
  ::tapdata::MessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tapdata.GetReadLogTaskStateResponse.header)
  return _msg;
}
inline void GetReadLogTaskStateResponse::set_allocated_header(::tapdata::MessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::MessageHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tapdata.GetReadLogTaskStateResponse.header)
}

// .tapdata.ResponseCode code = 2;
inline void GetReadLogTaskStateResponse::clear_code() {
  code_ = 0;
}
inline ::tapdata::ResponseCode GetReadLogTaskStateResponse::_internal_code() const {
  return static_cast< ::tapdata::ResponseCode >(code_);
}
inline ::tapdata::ResponseCode GetReadLogTaskStateResponse::code() const {
  // @@protoc_insertion_point(field_get:tapdata.GetReadLogTaskStateResponse.code)
  return _internal_code();
}
inline void GetReadLogTaskStateResponse::_internal_set_code(::tapdata::ResponseCode value) {
  
  code_ = value;
}
inline void GetReadLogTaskStateResponse::set_code(::tapdata::ResponseCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tapdata.GetReadLogTaskStateResponse.code)
}

// repeated .tapdata.ReadLogTaskState taskState = 3;
inline int GetReadLogTaskStateResponse::_internal_taskstate_size() const {
  return taskstate_.size();
}
inline int GetReadLogTaskStateResponse::taskstate_size() const {
  return _internal_taskstate_size();
}
inline void GetReadLogTaskStateResponse::clear_taskstate() {
  taskstate_.Clear();
}
inline ::tapdata::ReadLogTaskState* GetReadLogTaskStateResponse::mutable_taskstate(int index) {
  // @@protoc_insertion_point(field_mutable:tapdata.GetReadLogTaskStateResponse.taskState)
  return taskstate_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogTaskState >*
GetReadLogTaskStateResponse::mutable_taskstate() {
  // @@protoc_insertion_point(field_mutable_list:tapdata.GetReadLogTaskStateResponse.taskState)
  return &taskstate_;
}
inline const ::tapdata::ReadLogTaskState& GetReadLogTaskStateResponse::_internal_taskstate(int index) const {
  return taskstate_.Get(index);
}
inline const ::tapdata::ReadLogTaskState& GetReadLogTaskStateResponse::taskstate(int index) const {
  // @@protoc_insertion_point(field_get:tapdata.GetReadLogTaskStateResponse.taskState)
  return _internal_taskstate(index);
}
inline ::tapdata::ReadLogTaskState* GetReadLogTaskStateResponse::_internal_add_taskstate() {
  return taskstate_.Add();
}
inline ::tapdata::ReadLogTaskState* GetReadLogTaskStateResponse::add_taskstate() {
  ::tapdata::ReadLogTaskState* _add = _internal_add_taskstate();
  // @@protoc_insertion_point(field_add:tapdata.GetReadLogTaskStateResponse.taskState)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogTaskState >&
GetReadLogTaskStateResponse::taskstate() const {
  // @@protoc_insertion_point(field_list:tapdata.GetReadLogTaskStateResponse.taskState)
  return taskstate_;
}

// -------------------------------------------------------------------

// ReadLogPayload

// .tapdata.ReadLogOp op = 1;
inline void ReadLogPayload::clear_op() {
  op_ = 0;
}
inline ::tapdata::ReadLogOp ReadLogPayload::_internal_op() const {
  return static_cast< ::tapdata::ReadLogOp >(op_);
}
inline ::tapdata::ReadLogOp ReadLogPayload::op() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.op)
  return _internal_op();
}
inline void ReadLogPayload::_internal_set_op(::tapdata::ReadLogOp value) {
  
  op_ = value;
}
inline void ReadLogPayload::set_op(::tapdata::ReadLogOp value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.op)
}

// string scn = 2;
inline void ReadLogPayload::clear_scn() {
  scn_.ClearToEmpty();
}
inline const std::string& ReadLogPayload::scn() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.scn)
  return _internal_scn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogPayload::set_scn(ArgT0&& arg0, ArgT... args) {
 
 scn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.scn)
}
inline std::string* ReadLogPayload::mutable_scn() {
  std::string* _s = _internal_mutable_scn();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogPayload.scn)
  return _s;
}
inline const std::string& ReadLogPayload::_internal_scn() const {
  return scn_.Get();
}
inline void ReadLogPayload::_internal_set_scn(const std::string& value) {
  
  scn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::_internal_mutable_scn() {
  
  return scn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::release_scn() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogPayload.scn)
  return scn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogPayload::set_allocated_scn(std::string* scn) {
  if (scn != nullptr) {
    
  } else {
    
  }
  scn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scn,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogPayload.scn)
}

// bytes logBytes = 3;
inline void ReadLogPayload::clear_logbytes() {
  logbytes_.ClearToEmpty();
}
inline const std::string& ReadLogPayload::logbytes() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.logBytes)
  return _internal_logbytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogPayload::set_logbytes(ArgT0&& arg0, ArgT... args) {
 
 logbytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.logBytes)
}
inline std::string* ReadLogPayload::mutable_logbytes() {
  std::string* _s = _internal_mutable_logbytes();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogPayload.logBytes)
  return _s;
}
inline const std::string& ReadLogPayload::_internal_logbytes() const {
  return logbytes_.Get();
}
inline void ReadLogPayload::_internal_set_logbytes(const std::string& value) {
  
  logbytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::_internal_mutable_logbytes() {
  
  return logbytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::release_logbytes() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogPayload.logBytes)
  return logbytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogPayload::set_allocated_logbytes(std::string* logbytes) {
  if (logbytes != nullptr) {
    
  } else {
    
  }
  logbytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logbytes,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogPayload.logBytes)
}

// int64 transactionTime = 4;
inline void ReadLogPayload::clear_transactiontime() {
  transactiontime_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReadLogPayload::_internal_transactiontime() const {
  return transactiontime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReadLogPayload::transactiontime() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.transactionTime)
  return _internal_transactiontime();
}
inline void ReadLogPayload::_internal_set_transactiontime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  transactiontime_ = value;
}
inline void ReadLogPayload::set_transactiontime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_transactiontime(value);
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.transactionTime)
}

// string transactionId = 5;
inline void ReadLogPayload::clear_transactionid() {
  transactionid_.ClearToEmpty();
}
inline const std::string& ReadLogPayload::transactionid() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.transactionId)
  return _internal_transactionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogPayload::set_transactionid(ArgT0&& arg0, ArgT... args) {
 
 transactionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.transactionId)
}
inline std::string* ReadLogPayload::mutable_transactionid() {
  std::string* _s = _internal_mutable_transactionid();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogPayload.transactionId)
  return _s;
}
inline const std::string& ReadLogPayload::_internal_transactionid() const {
  return transactionid_.Get();
}
inline void ReadLogPayload::_internal_set_transactionid(const std::string& value) {
  
  transactionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::_internal_mutable_transactionid() {
  
  return transactionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::release_transactionid() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogPayload.transactionId)
  return transactionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogPayload::set_allocated_transactionid(std::string* transactionid) {
  if (transactionid != nullptr) {
    
  } else {
    
  }
  transactionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transactionid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogPayload.transactionId)
}

// int32 tableId = 6;
inline void ReadLogPayload::clear_tableid() {
  tableid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReadLogPayload::_internal_tableid() const {
  return tableid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReadLogPayload::tableid() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.tableId)
  return _internal_tableid();
}
inline void ReadLogPayload::_internal_set_tableid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tableid_ = value;
}
inline void ReadLogPayload::set_tableid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tableid(value);
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.tableId)
}

// int32 tableSpaceId = 7;
inline void ReadLogPayload::clear_tablespaceid() {
  tablespaceid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReadLogPayload::_internal_tablespaceid() const {
  return tablespaceid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ReadLogPayload::tablespaceid() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.tableSpaceId)
  return _internal_tablespaceid();
}
inline void ReadLogPayload::_internal_set_tablespaceid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tablespaceid_ = value;
}
inline void ReadLogPayload::set_tablespaceid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tablespaceid(value);
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.tableSpaceId)
}

// string rid = 8;
inline void ReadLogPayload::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& ReadLogPayload::rid() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogPayload::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.rid)
}
inline std::string* ReadLogPayload::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogPayload.rid)
  return _s;
}
inline const std::string& ReadLogPayload::_internal_rid() const {
  return rid_.Get();
}
inline void ReadLogPayload::_internal_set_rid(const std::string& value) {
  
  rid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::_internal_mutable_rid() {
  
  return rid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::release_rid() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogPayload.rid)
  return rid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogPayload::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogPayload.rid)
}

// string defaultSchema = 9;
inline void ReadLogPayload::clear_defaultschema() {
  defaultschema_.ClearToEmpty();
}
inline const std::string& ReadLogPayload::defaultschema() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.defaultSchema)
  return _internal_defaultschema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogPayload::set_defaultschema(ArgT0&& arg0, ArgT... args) {
 
 defaultschema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.defaultSchema)
}
inline std::string* ReadLogPayload::mutable_defaultschema() {
  std::string* _s = _internal_mutable_defaultschema();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogPayload.defaultSchema)
  return _s;
}
inline const std::string& ReadLogPayload::_internal_defaultschema() const {
  return defaultschema_.Get();
}
inline void ReadLogPayload::_internal_set_defaultschema(const std::string& value) {
  
  defaultschema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::_internal_mutable_defaultschema() {
  
  return defaultschema_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::release_defaultschema() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogPayload.defaultSchema)
  return defaultschema_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogPayload::set_allocated_defaultschema(std::string* defaultschema) {
  if (defaultschema != nullptr) {
    
  } else {
    
  }
  defaultschema_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), defaultschema,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogPayload.defaultSchema)
}

// string schema = 10;
inline void ReadLogPayload::clear_schema() {
  schema_.ClearToEmpty();
}
inline const std::string& ReadLogPayload::schema() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogPayload::set_schema(ArgT0&& arg0, ArgT... args) {
 
 schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.schema)
}
inline std::string* ReadLogPayload::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogPayload.schema)
  return _s;
}
inline const std::string& ReadLogPayload::_internal_schema() const {
  return schema_.Get();
}
inline void ReadLogPayload::_internal_set_schema(const std::string& value) {
  
  schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::_internal_mutable_schema() {
  
  return schema_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::release_schema() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogPayload.schema)
  return schema_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogPayload::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    
  } else {
    
  }
  schema_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogPayload.schema)
}

// string tableName = 11;
inline void ReadLogPayload::clear_tablename() {
  tablename_.ClearToEmpty();
}
inline const std::string& ReadLogPayload::tablename() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.tableName)
  return _internal_tablename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogPayload::set_tablename(ArgT0&& arg0, ArgT... args) {
 
 tablename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.tableName)
}
inline std::string* ReadLogPayload::mutable_tablename() {
  std::string* _s = _internal_mutable_tablename();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogPayload.tableName)
  return _s;
}
inline const std::string& ReadLogPayload::_internal_tablename() const {
  return tablename_.Get();
}
inline void ReadLogPayload::_internal_set_tablename(const std::string& value) {
  
  tablename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::_internal_mutable_tablename() {
  
  return tablename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::release_tablename() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogPayload.tableName)
  return tablename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogPayload::set_allocated_tablename(std::string* tablename) {
  if (tablename != nullptr) {
    
  } else {
    
  }
  tablename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tablename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogPayload.tableName)
}

// bytes beforeLogBytes = 12;
inline void ReadLogPayload::clear_beforelogbytes() {
  beforelogbytes_.ClearToEmpty();
}
inline const std::string& ReadLogPayload::beforelogbytes() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.beforeLogBytes)
  return _internal_beforelogbytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogPayload::set_beforelogbytes(ArgT0&& arg0, ArgT... args) {
 
 beforelogbytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.beforeLogBytes)
}
inline std::string* ReadLogPayload::mutable_beforelogbytes() {
  std::string* _s = _internal_mutable_beforelogbytes();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogPayload.beforeLogBytes)
  return _s;
}
inline const std::string& ReadLogPayload::_internal_beforelogbytes() const {
  return beforelogbytes_.Get();
}
inline void ReadLogPayload::_internal_set_beforelogbytes(const std::string& value) {
  
  beforelogbytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::_internal_mutable_beforelogbytes() {
  
  return beforelogbytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::release_beforelogbytes() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogPayload.beforeLogBytes)
  return beforelogbytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogPayload::set_allocated_beforelogbytes(std::string* beforelogbytes) {
  if (beforelogbytes != nullptr) {
    
  } else {
    
  }
  beforelogbytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), beforelogbytes,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogPayload.beforeLogBytes)
}

// string pendingMinScn = 13;
inline void ReadLogPayload::clear_pendingminscn() {
  pendingminscn_.ClearToEmpty();
}
inline const std::string& ReadLogPayload::pendingminscn() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogPayload.pendingMinScn)
  return _internal_pendingminscn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogPayload::set_pendingminscn(ArgT0&& arg0, ArgT... args) {
 
 pendingminscn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogPayload.pendingMinScn)
}
inline std::string* ReadLogPayload::mutable_pendingminscn() {
  std::string* _s = _internal_mutable_pendingminscn();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogPayload.pendingMinScn)
  return _s;
}
inline const std::string& ReadLogPayload::_internal_pendingminscn() const {
  return pendingminscn_.Get();
}
inline void ReadLogPayload::_internal_set_pendingminscn(const std::string& value) {
  
  pendingminscn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::_internal_mutable_pendingminscn() {
  
  return pendingminscn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogPayload::release_pendingminscn() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogPayload.pendingMinScn)
  return pendingminscn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogPayload::set_allocated_pendingminscn(std::string* pendingminscn) {
  if (pendingminscn != nullptr) {
    
  } else {
    
  }
  pendingminscn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pendingminscn,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogPayload.pendingMinScn)
}

// -------------------------------------------------------------------

// ReadLogResponse

// .tapdata.MessageHeader header = 1;
inline bool ReadLogResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ReadLogResponse::has_header() const {
  return _internal_has_header();
}
inline void ReadLogResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::tapdata::MessageHeader& ReadLogResponse::_internal_header() const {
  const ::tapdata::MessageHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::MessageHeader&>(
      ::tapdata::_MessageHeader_default_instance_);
}
inline const ::tapdata::MessageHeader& ReadLogResponse::header() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogResponse.header)
  return _internal_header();
}
inline void ReadLogResponse::unsafe_arena_set_allocated_header(
    ::tapdata::MessageHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.ReadLogResponse.header)
}
inline ::tapdata::MessageHeader* ReadLogResponse::release_header() {
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::MessageHeader* ReadLogResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogResponse.header)
  
  ::tapdata::MessageHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::tapdata::MessageHeader* ReadLogResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::MessageHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::tapdata::MessageHeader* ReadLogResponse::mutable_header() {
  ::tapdata::MessageHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogResponse.header)
  return _msg;
}
inline void ReadLogResponse::set_allocated_header(::tapdata::MessageHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::MessageHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogResponse.header)
}

// .tapdata.ResponseCode code = 2;
inline void ReadLogResponse::clear_code() {
  code_ = 0;
}
inline ::tapdata::ResponseCode ReadLogResponse::_internal_code() const {
  return static_cast< ::tapdata::ResponseCode >(code_);
}
inline ::tapdata::ResponseCode ReadLogResponse::code() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogResponse.code)
  return _internal_code();
}
inline void ReadLogResponse::_internal_set_code(::tapdata::ResponseCode value) {
  
  code_ = value;
}
inline void ReadLogResponse::set_code(::tapdata::ResponseCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tapdata.ReadLogResponse.code)
}

// string payloadVersion = 3;
inline void ReadLogResponse::clear_payloadversion() {
  payloadversion_.ClearToEmpty();
}
inline const std::string& ReadLogResponse::payloadversion() const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogResponse.payloadVersion)
  return _internal_payloadversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadLogResponse::set_payloadversion(ArgT0&& arg0, ArgT... args) {
 
 payloadversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.ReadLogResponse.payloadVersion)
}
inline std::string* ReadLogResponse::mutable_payloadversion() {
  std::string* _s = _internal_mutable_payloadversion();
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogResponse.payloadVersion)
  return _s;
}
inline const std::string& ReadLogResponse::_internal_payloadversion() const {
  return payloadversion_.Get();
}
inline void ReadLogResponse::_internal_set_payloadversion(const std::string& value) {
  
  payloadversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadLogResponse::_internal_mutable_payloadversion() {
  
  return payloadversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadLogResponse::release_payloadversion() {
  // @@protoc_insertion_point(field_release:tapdata.ReadLogResponse.payloadVersion)
  return payloadversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadLogResponse::set_allocated_payloadversion(std::string* payloadversion) {
  if (payloadversion != nullptr) {
    
  } else {
    
  }
  payloadversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payloadversion,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.ReadLogResponse.payloadVersion)
}

// repeated .tapdata.ReadLogPayload payload = 4;
inline int ReadLogResponse::_internal_payload_size() const {
  return payload_.size();
}
inline int ReadLogResponse::payload_size() const {
  return _internal_payload_size();
}
inline void ReadLogResponse::clear_payload() {
  payload_.Clear();
}
inline ::tapdata::ReadLogPayload* ReadLogResponse::mutable_payload(int index) {
  // @@protoc_insertion_point(field_mutable:tapdata.ReadLogResponse.payload)
  return payload_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogPayload >*
ReadLogResponse::mutable_payload() {
  // @@protoc_insertion_point(field_mutable_list:tapdata.ReadLogResponse.payload)
  return &payload_;
}
inline const ::tapdata::ReadLogPayload& ReadLogResponse::_internal_payload(int index) const {
  return payload_.Get(index);
}
inline const ::tapdata::ReadLogPayload& ReadLogResponse::payload(int index) const {
  // @@protoc_insertion_point(field_get:tapdata.ReadLogResponse.payload)
  return _internal_payload(index);
}
inline ::tapdata::ReadLogPayload* ReadLogResponse::_internal_add_payload() {
  return payload_.Add();
}
inline ::tapdata::ReadLogPayload* ReadLogResponse::add_payload() {
  ::tapdata::ReadLogPayload* _add = _internal_add_payload();
  // @@protoc_insertion_point(field_add:tapdata.ReadLogResponse.payload)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tapdata::ReadLogPayload >&
ReadLogResponse::payload() const {
  // @@protoc_insertion_point(field_list:tapdata.ReadLogResponse.payload)
  return payload_;
}

// -------------------------------------------------------------------

// PushReadLogResponse

// .tapdata.PushResponseCode code = 1;
inline void PushReadLogResponse::clear_code() {
  code_ = 0;
}
inline ::tapdata::PushResponseCode PushReadLogResponse::_internal_code() const {
  return static_cast< ::tapdata::PushResponseCode >(code_);
}
inline ::tapdata::PushResponseCode PushReadLogResponse::code() const {
  // @@protoc_insertion_point(field_get:tapdata.PushReadLogResponse.code)
  return _internal_code();
}
inline void PushReadLogResponse::_internal_set_code(::tapdata::PushResponseCode value) {
  
  code_ = value;
}
inline void PushReadLogResponse::set_code(::tapdata::PushResponseCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tapdata.PushReadLogResponse.code)
}

// int32 waitTimeMS = 2;
inline void PushReadLogResponse::clear_waittimems() {
  waittimems_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PushReadLogResponse::_internal_waittimems() const {
  return waittimems_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PushReadLogResponse::waittimems() const {
  // @@protoc_insertion_point(field_get:tapdata.PushReadLogResponse.waitTimeMS)
  return _internal_waittimems();
}
inline void PushReadLogResponse::_internal_set_waittimems(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  waittimems_ = value;
}
inline void PushReadLogResponse::set_waittimems(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_waittimems(value);
  // @@protoc_insertion_point(field_set:tapdata.PushReadLogResponse.waitTimeMS)
}

// -------------------------------------------------------------------

// PushReadLogRequest

// string id = 1;
inline void PushReadLogRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& PushReadLogRequest::id() const {
  // @@protoc_insertion_point(field_get:tapdata.PushReadLogRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushReadLogRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tapdata.PushReadLogRequest.id)
}
inline std::string* PushReadLogRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:tapdata.PushReadLogRequest.id)
  return _s;
}
inline const std::string& PushReadLogRequest::_internal_id() const {
  return id_.Get();
}
inline void PushReadLogRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PushReadLogRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PushReadLogRequest::release_id() {
  // @@protoc_insertion_point(field_release:tapdata.PushReadLogRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PushReadLogRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:tapdata.PushReadLogRequest.id)
}

// .tapdata.ReadLogResponse logResponse = 2;
inline bool PushReadLogRequest::_internal_has_logresponse() const {
  return this != internal_default_instance() && logresponse_ != nullptr;
}
inline bool PushReadLogRequest::has_logresponse() const {
  return _internal_has_logresponse();
}
inline void PushReadLogRequest::clear_logresponse() {
  if (GetArenaForAllocation() == nullptr && logresponse_ != nullptr) {
    delete logresponse_;
  }
  logresponse_ = nullptr;
}
inline const ::tapdata::ReadLogResponse& PushReadLogRequest::_internal_logresponse() const {
  const ::tapdata::ReadLogResponse* p = logresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::tapdata::ReadLogResponse&>(
      ::tapdata::_ReadLogResponse_default_instance_);
}
inline const ::tapdata::ReadLogResponse& PushReadLogRequest::logresponse() const {
  // @@protoc_insertion_point(field_get:tapdata.PushReadLogRequest.logResponse)
  return _internal_logresponse();
}
inline void PushReadLogRequest::unsafe_arena_set_allocated_logresponse(
    ::tapdata::ReadLogResponse* logresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logresponse_);
  }
  logresponse_ = logresponse;
  if (logresponse) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tapdata.PushReadLogRequest.logResponse)
}
inline ::tapdata::ReadLogResponse* PushReadLogRequest::release_logresponse() {
  
  ::tapdata::ReadLogResponse* temp = logresponse_;
  logresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tapdata::ReadLogResponse* PushReadLogRequest::unsafe_arena_release_logresponse() {
  // @@protoc_insertion_point(field_release:tapdata.PushReadLogRequest.logResponse)
  
  ::tapdata::ReadLogResponse* temp = logresponse_;
  logresponse_ = nullptr;
  return temp;
}
inline ::tapdata::ReadLogResponse* PushReadLogRequest::_internal_mutable_logresponse() {
  
  if (logresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::tapdata::ReadLogResponse>(GetArenaForAllocation());
    logresponse_ = p;
  }
  return logresponse_;
}
inline ::tapdata::ReadLogResponse* PushReadLogRequest::mutable_logresponse() {
  ::tapdata::ReadLogResponse* _msg = _internal_mutable_logresponse();
  // @@protoc_insertion_point(field_mutable:tapdata.PushReadLogRequest.logResponse)
  return _msg;
}
inline void PushReadLogRequest::set_allocated_logresponse(::tapdata::ReadLogResponse* logresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete logresponse_;
  }
  if (logresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tapdata::ReadLogResponse>::GetOwningArena(logresponse);
    if (message_arena != submessage_arena) {
      logresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logresponse, submessage_arena);
    }
    
  } else {
    
  }
  logresponse_ = logresponse;
  // @@protoc_insertion_point(field_set_allocated:tapdata.PushReadLogRequest.logResponse)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tapdata

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tapdata::WriterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tapdata::WriterType>() {
  return ::tapdata::WriterType_descriptor();
}
template <> struct is_proto_enum< ::tapdata::DB2Veresion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tapdata::DB2Veresion>() {
  return ::tapdata::DB2Veresion_descriptor();
}
template <> struct is_proto_enum< ::tapdata::ResponseCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tapdata::ResponseCode>() {
  return ::tapdata::ResponseCode_descriptor();
}
template <> struct is_proto_enum< ::tapdata::TaskState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tapdata::TaskState>() {
  return ::tapdata::TaskState_descriptor();
}
template <> struct is_proto_enum< ::tapdata::ReadLogOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tapdata::ReadLogOp>() {
  return ::tapdata::ReadLogOp_descriptor();
}
template <> struct is_proto_enum< ::tapdata::PushResponseCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tapdata::PushResponseCode>() {
  return ::tapdata::PushResponseCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_DB2PlugInDataSource_2eproto
